<section xml:id="inheritance-exercises">
  <title>Inheritance Exercises</title>
 
  <p>
 (Note: For programming exercises,
    <term>first</term> draw a UML class diagram describing all classes and their 
    inheritance relationships and/or associations.)
  </p>

<exercises>
 <exercisegroup>
<title>Fill in the blank</title>
    <introduction>
     <p>
        Fill in the blanks in each of the following sentences:
      </p>
	</introduction>
        
        
          <exercise label="jinx_fill_blank_1">       
 <statement>
          <p>
            A method that lacks a body is an <var width="15"/> method.
          </p>
          </statement>       
<setup>
          <var case="insensitive">
            <condition string="abstract">
              <feedback>
		<p>Correct</p>
              </feedback>
            </condition>
	    <condition string="empty">
              <feedback>
		<p>Try again. An empty body is still a body</p>
              </feedback>
            </condition>
            <condition string=".*">
              <feedback>
		<p>Try again. You may want to review the technical terms from this chapter.</p>
              </feedback>
            </condition>
          </var>
	</setup>	
    
 </exercise>
           
          <exercise label="jinx_fill_blank_2">       
 <statement>
          <p>
            An <var width="15"/> is like a class except that it contains only instance methods,
            no instance variables.
          </p>
                  </statement>       
<setup>
          <var case="insensitive">
            <condition string="interface">
              <feedback>
		<p>Correct</p>
              </feedback>
            </condition>
	    <condition string="abstract class">
              <feedback>
		<p>Try again. An abstract class can have instance
		variables and methods. It just needs to have one
		abstract method.</p>
              </feedback>
            </condition>
            <condition string=".*">
              <feedback>
		<p>Try again. You may want to review the technical terms from this chapter.</p>
              </feedback>
            </condition>
          </var>
	</setup>	
    
 </exercise>
           
          <exercise label="jinx_fill_blank_3">       
 <statement>

          <p>
            Two ways for a class to inherit something in Java is to <var width="15"/> a 
            class and <var width="15"/> an interface.
          </p>
                  </statement>       
<setup>
          <var case="insensitive">
            <condition string="extend">
              <feedback>
		<p>Correct</p>
              </feedback>
            </condition>
	    <condition string="implement">
              <feedback>
		<p>Try again. Interfaces are implemented</p>
              </feedback>
            </condition>
            <condition string=".*">
              <feedback>
		<p>Try again. You may want to review the technical terms from this chapter.</p>
              </feedback>
            </condition>
          </var>
	  <var case="insensitive">
            <condition string="implement">
              <feedback>
		<p>Correct</p>
              </feedback>
            </condition>
	    <condition string="extend">
              <feedback>
		<p>Try again. Interfaces can extend each other, but a
		class cannot extend an interface.</p>
              </feedback>
            </condition>
            <condition string=".*">
              <feedback>
		<p>Try again. You may want to review the technical terms from this chapter.</p>
              </feedback>
            </condition>
          </var>
	</setup>	
    
 </exercise>
           
          <exercise label="jinx_fill_blank_4">       
 <statement>

          <p>
            Instance variables and instance methods that are declared
	    <var width="15"/> or <var width="15"/> are inherited and usable by the subclasses.
          </p>
                  </statement>       
<setup>
          <var case="insensitive">
            <condition string="protected">
              <feedback>
		<p>Correct</p>
              </feedback>
            </condition>
	    <condition string="public">
              <feedback>
		<p>Try again. public is expected as the second term.</p>
              </feedback>
            </condition>
	    <condition string="private">
              <feedback>
		<p>Try again. the private modifier makes it unusable
		by subclasses.</p>
              </feedback>
            </condition>
	    <condition string="static">
              <feedback>
		<p>Try again. the static modifier makes a variable or
		method a class variable or class method instead of an
		instance variable or instance method.</p>
              </feedback>
            </condition>
	    <condition string="abstract">
              <feedback>
		<p>Try again. the abstract modifier can't be used on
		variables, only methods.</p>
              </feedback>
            </condition>
            <condition string=".*">
              <feedback>
		<p>Try again. You may want to review the technical terms from this chapter.</p>
              </feedback>
            </condition>
          </var>
	  <var case="insensitive">
            <condition string="public">
              <feedback>
		<p>Correct</p>
              </feedback>
            </condition>
	    <condition string="protected">
              <feedback>
		<p>Try again. protected is expected as the second term.</p>
              </feedback>
            </condition>
	    <condition string="private">
              <feedback>
		<p>Try again. the private modifier makes it unusable
		by subclasses.</p>
              </feedback>
            </condition>
	    <condition string="static">
              <feedback>
		<p>Try again. the static modifier makes a variable or
		method a class variable or class method instead of an
		instance variable or instance method.</p>
              </feedback>
            </condition>
	    <condition string="abstract">
              <feedback>
		<p>Try again. the abstract modifier can't be used on
		variables, only methods.</p>
              </feedback>
            </condition>
            <condition string=".*">
              <feedback>
		<p>Try again. You may want to review the technical terms from this chapter.</p>
              </feedback>
            </condition>
          </var>
	</setup>	
    
 </exercise>
           
          <exercise label="jinx_fill_blank_5">       
 <statement>

          <p>
            An object can refer to itself by using the <var width="15"/> keyword.
          </p>
                  </statement>       
<setup>
          <var case="insensitive">
            <condition string="this">
              <feedback>
		<p>Correct</p>
              </feedback>
            </condition>
	    <condition string="super">
              <feedback>
		<p>Try again. super is used to refer to only the
		parent part of itself</p>
              </feedback>
            </condition>
	    <condition string="self">
              <feedback>
		<p>Try again. self is not a keyword in java, but it is
		used sometimes in python</p>
              </feedback>
            </condition>
            <condition string=".*">
              <feedback>
		<p>Try again. You may want to review the technical terms from this chapter.</p>
              </feedback>
            </condition>
          </var>
	</setup>	
    
 </exercise>
           
          <exercise label="jinx_fill_blank_6">       
 <statement>

          <p>
            If a GUI class intends to handle <c>ActionEvent</c> s, it must implement the <var width="15"/> interface.
          </p>
                  </statement>       
<setup>
          <var>
            <condition string="ActionListener">
              <feedback>
		<p>Correct</p>
              </feedback>
            </condition>
	    <condition string="EventListener">
              <feedback>
		<p>Try again. An EventListener is too general and has
		no methods to implement.</p>
              </feedback>
            </condition>
            <condition string=".*">
              <feedback>
		<p>Try again. Remember, classes and interfaces in java
		are case sensitive. You may want to review the technical terms from this chapter.</p>
              </feedback>
            </condition>
          </var>
	</setup>	
    
 </exercise>
           
          <exercise label="jinx_fill_blank_7">       
 <statement>

          <p>
            A <var width="15"/> method is one that does different things depending upon the object that invokes it.
          </p>
                  </statement>       
<setup>
          <var case="insensitive">
            <condition string="polymorphic">
              <feedback>
		<p>Correct</p>
              </feedback>
            </condition>
	    <condition string="overloaded">
              <feedback>
		<p>Try again. An overloaded method does different
		things depending on the arguments passed to it.</p>
              </feedback>
            </condition>
	     <condition string="overridden">
              <feedback>
		<p>Try again. An overridden method does different
		things if the object is a subclass of the base class
		with the method.</p>
              </feedback>
            </condition>
            <condition string=".*">
              <feedback>
		<p>Try again. You may want to review the technical terms from this chapter.</p>
              </feedback>
            </condition>
          </var>
	</setup>	
    
 </exercise>
           
</exercisegroup>

<exercise label="jinx_matching_java_definitions">
      <title>Java Concept Matching</title>
      <statement>
	<p>
          Explain the difference between each of the following pairs of concepts.
	</p>
      </statement>
      <matches>
	<match>
	  <order>1</order>
          <premise><em>class</em></premise>
          <response>defines variables/fields, abstract methods, and
	  implemented methods </response>
	</match>
	<match>
	  <order>2</order>
          <premise><em>interface</em></premise>
          <response>defines only abstract methods and final variables/fields</response>
	</match>
	<match>
	  <order>3</order>
          <premise><em>stub</em> method</premise>
          <response>partially implemented method that works enough for
	  the program to compile</response>
	</match>
	<match>
	  <order>4</order>
          <premise><em>abstract</em> method</premise>
          <response>a method with no body or implementation</response>
	</match>
	<match>
	  <order>5</order>
	  <premise><em>extending</em> a class</premise>
          <response>using the <c>extends</c> keyword to create an
	  inheritance relationship between the class being defined
	  and the class being extended.</response>
	</match>
	<match>
	  <order>6</order>
          <premise><em>instantiating</em> an object</premise>
          <response>using the <c>new</c> keyword before a constructor
	  in order to allocate memory for an object to be used</response>
	</match>
	<match>
	  <order>7</order>
          <premise><em>defining a method</em></premise>
          <response>writing the method header in a class</response>
	</match>
	<match>
	  <order>8</order>
          <premise><em>implementing a method</em></premise>
          <response>writing the body of a method</response>
	</match>
	<match>
	  <order>9</order>
          <premise>a <c>protected</c> method</premise>
          <response>a method that can be called by an object or class that is
	  a subclass of or a class in the same package as the class that
	  the method is defined in.</response>
	</match>
	<match>
	  <order>10</order>
          <premise>a <c>private</c> method</premise>
          <response>a method that can only be called by an object or class that
	  is the exact same class that the method is defined in</response>
	</match>
	<match>
	  <order>11</order>
          <premise>a <c>public</c> method</premise>
          <response>a method that can be called by any object or class</response>
	</match>
	<match>
	  <order>12</order>
          <premise>a <em>package</em> method</premise>
          <response>a method that can only be called by any object or class
	  that is in the same package as the class the method is
	  defined in.</response>
	</match>

	
      </matches>
    </exercise>

     
     <exercise label="jinx_hierarchy_parsons" indentation="hide" language="python">
      <title>Language Hierarchy</title>
      <statement>
 
    
      <p>
        Create a hierarchy to represent the following situation.
        There are lots of languages in the world.
        English, French, Chinese, and Korean are examples of natural languages.
        Java, C, and C++ are examples of formal languages.
        French and Italian are considered romance languages,
        while Greek and Latin are considered classical languages.
	Note: Indenting a language puts it on a lower level. Languages
	on the same level should be in alphabetical order, but
	languages that don't have children should precede languages
	that do.
	
      </p>
      </statement>
            <blocks >
	<block name="a">
	  <cline>Languages:</cline> 
	</block>
	<block name="b">
	  <cline>    Formal Languages:</cline>
	</block>
	<block name="f">
	  <cline>        C++</cline>
	</block>
	<block name="g">
	  <cline>        Fortran</cline>
	</block>
	<block name="h">
	  <cline>        Java</cline>
	</block>
	<block name="c">
	  <cline>    Natural Languages:</cline>
	</block>
	<block name="i">
          <cline>        English</cline>
	</block>
	<block name="j">
	  <cline>        Japanese</cline>
	</block>
	<block name="k">
	  <cline>        Korean</cline>
	</block>
	<block name="d">
	  <cline>        Classical Languages:</cline>
	</block>
	<block name="l">
	  <cline>            Greek</cline>
	</block>
	<block name="m">
	  <cline>            Latin</cline>
	</block>
        <block name="e">
	  <cline>        Romance Languages:</cline>
	</block>
	<block name="n">
	  <cline>            French</cline>
	</block>
	<block name="o">
	  <cline>            Italian</cline>
	</block>
      </blocks>

    </exercise>
    <exercise label="jinx_jbutton_methods">
      <title>JButton Methods</title>
     
 <statement>

      <p>
        Look up the documentation for the <c>JButton</c> class on Sun's Web site:
 <url href="http://java.sun.com/j2se/1.5.0/docs/api/" visual="">http://java.sun.com/j2se/1.5.0/docs/api/</url>.
List the names of all the methods that would be inherited by the <c>ToggleButton</c> subclass that we defined in this chapter.
      </p>
    </statement>
      <response />
    </exercise>
               <exercise label="jinx_toggle_button_tostring">
      <title>Toggle Button toString()</title>       
 <statement>

      <p>
        Design and write a <c>toString()</c> method for the <c>ToggleButton</c> class 
        defined in this chapter.
        The <c>toString()</c> method should return the <c>ToggleButton</c>'s current label.
      </p>
    </statement>
      <response />
    </exercise>
               <exercise label="jinx_employee_class_hierarchy" attachment="yes">
      <title>Employee Class Hierarchy</title>       
 <statement>

      <p>
        Design a class hierarchy rooted in the class <c>Employee</c> that includes subclasses for <c>HourlyEmployee</c> and <c>SalaryEmployee</c>. The attributes shared in common by these classes include the name,
        and job title of the employee,
        plus the accessor and mutator methods needed by those attributes.
        The salaried employees need an attribute for weekly salary,
        and the corresponding methods for accessing and changing this variable.
        The hourly employees should have a pay rate and an hours worked variable.
        There should be an abstract method called <c>calculateWeeklyPay()</c>, defined 
        abstractly in the superclass and implemented in the subclasses.
        The salaried worker's pay is just the weekly salary.
        Pay for an hourly employee is simply hours worked times pay rate.
      </p>
    </statement>
      <response />
    </exercise>
               <exercise label="jinx_code_integer_field" attachment="yes">
      <title>Write IntegerField</title>       
 <statement>

      <p>
        Design and write a subclass of <c>JTextField</c> called <c>IntegerField</c> that is 
        used for inputting integers but behaves in all other respects 
        like a <c>JTextField</c>. Give the subclass a public method called <c>getInteger()</c>.
      </p>
    </statement>
      <response />
    </exercise>
               <exercise label="jinx_code_increasing_shift_cipher">
      <title>Increasing Shift Cipher</title>       
 <statement>

      <p>
        Implement a method that uses the following variation of the Caesar cipher.
        The method should take two parameters,
        a <c>String</c> and an <c>int</c> <em>N</em>.
        The result should be a <c>String</c> in which the first letter is shifted by <em>N</em>,
        the second by <m>N+1</m>, the third by <m>N+2</m>, and so on.
        For example, given the string
        <q>Hello,</q>
        and an initial shift of 1, your method should return
        <q>Igopt.</q>
        Write a method that converts its <c>String</c> parameter so that 
        letters are written in blocks five characters long.
      </p>
    </statement>
      <program label="jinx_shift_prg" interactive="activecode" language="java">
<input>
	    public class Program {
		
		public static void main(String args[]) {
		    
		}
	    }
</input>
</program>    

    </exercise>
               
               <exercise label="jinx_code_substitution_cipher">
      <title>Substitution Cipher</title>       
 <statement>

      <p>
        Design and implement a <c>Cipher</c> subclass to implement the following 
        substitution cipher: Each letter in the alphabet is replaced with a 
        letter from the opposite end of the alphabet:
        <em>a</em> is replaced with <em>z</em>,
        <em>b</em> with <em>y</em>, and so forth.
      </p>
    </statement>
      <program label="jinx_substitution_prg" interactive="activecode" language="java">
<input>
	    public class Program {
		
		public static void main(String args[]) {
		    
		}
	    }
</input>
</program>    

    </exercise>
               <exercise label="jinx_code_alphabet_class">
      <title>Alphabet Class</title>       
 <statement>

      <p>
        One way to design a substitution alphabet for a cipher is to use a 
        keyword to construct the alphabet.
        For example, suppose the keyword is
        <q>zebra.</q>
        You place the keyword at the beginning of the alphabet,
        and then fill out the other 21 slots with remaining letters,
        giving the following alphabet:
 <program language="java"><input>
Cipher alphabet:   zebracdfghijklmnopqstuvwxy
Plain alphabet:    abcdefghijklmnopqrstuvwxyz
 </input></program>Design and implement an <c>Alphabet</c> class for constructing these kinds of substitution alphabets.
        It should have a single public method that takes a keyword <c>String</c> as an argument and returns an alphabet string.
        Note that an alphabet cannot contain duplicate letters,
        so repeated letters in a keyword like
        <q>xylophone</q>
        would have to be removed.
      </p>
    </statement>
      <program label="jinx_alphabet_prg" interactive="activecode" language="java">
<input>
	    public class Program {
		
		public static void main(String args[]) {
		    
		}
	    }
</input>
</program>    

    </exercise>
               <exercise label="jinx_code_alphabet_cipher">
      <title>Alphabet Cipher</title>       
 <statement>

      <p>
        Design and write a <c>Cipher</c> subclass for a substitution cipher that uses an alphabet from the <c>Alphabet</c> class created in the previous exercise.
        Challenge: Find a partner and concoct your own encryption scheme.
        Then work separately with one partner writing <c>encode()</c> and the other writing <c>decode()</c>. Test to see that a message can be encoded and then decoded to yield the original message.
      </p>
    </statement>
      <program label="jinx_alpha_cipher_prg" interactive="activecode" language="java">
<input>
	    public class Program {
		
		public static void main(String args[]) {
		    
		}
	    }
</input>
</program>    

    </exercise>
               <exercise label="jinx_code_multiplication_game">
      <title>Multiplication Game</title>       
 <statement>

      <p>
        Design a <c>TwoPlayerGame</c> subclass called <c>MultiplicationGame</c>. The 
        rules of this game are that the game generates a random multiplication problem 
        using numbers between 1 and 10, and the players,
        taking turns, try to provide the answer to the problem.
        The game ends when a wrong answer is given.
        The winner is the player who did not give a wrong answer.
      </p>
    </statement>
      <program label="jinx_mult_game_prg" interactive="activecode" language="java">
<input>
	    public class Program {
		
		public static void main(String args[]) {
		    
		}
	    }
</input>
</program>    

    </exercise>
               <exercise label="jinx_code_multiplication_player">
      <title>Multiplication Player</title>       
 <statement>

      <p>
        Design a class called <c>MultiplicationPlayer</c> that plays the multiplication game described in the previous exercise.
        This class should implement the <c>IPlayer</c> interface.
      </p>
    </statement>
      <program label="jinx_mult_player_prg" interactive="activecode" language="java">
<input>
	    public class Program {
		
		public static void main(String args[]) {
		    
		}
	    }
</input>
</program>    

    </exercise>
               <exercise label="jinx_code_rps_game">
      <title>Rock Paper Scissors Game</title>       
 <statement>

      <p>
        Design a <c>TwoPlayerGame</c> subclass called <c>RockPaperScissors</c>. The rules 
        of this game are that each player,
        at the same time, picks either a rock, a paper, or a scissors.
        For each round, the rock beats the scissors,
        the scissors beats the paper,
        and the paper beats the rock.
        Ties are allowed.
        The game is won in a best out of three fashion when one of the players wins two rounds.
      </p>
    </statement>
      <program label="jinx_rps_game_prg" interactive="activecode" language="java">
<input>
	    public class Program {
		
		public static void main(String args[]) {
		    
		}
	    }
</input>
</program>    

    </exercise>
               <exercise label="jinx_code_rps_player">
      <title>Rock Paper Scissors Player</title>       
 <statement>

      <p>
        Design a class called <c>RockPaperScissorsPlayer</c> that plays the the game 
        described in the previous exercise.
        This class should implement the <c>IPlayer</c> interface.
      </p>
    </statement>
      <program label="jinx_rps_player_prg" interactive="activecode" language="java">
<input>
	    public class Program {
		
		public static void main(String args[]) {
		    
		}
	    }
</input>
</program>    

    </exercise>
  
             <exercise label="jinx_uml_animal_hierarchy" attachment="yes">
      <title>Animal Hierarchy</title>       
 <statement>

    <p>
      Given the classes with the following headers

<program language="java">
<input>
public class Animal ...
public class DomesticAnimal extends Animal ...
public class FarmAnimal extends DomesticAnimal...
public class HousePet extends DomesticAnimal...
public class Cow extends FarmAnimal ...
public class Goat extends FarmAnimal ...
public class DairyCow extends Cow ...
</input>
</program>

draw a UML class diagram representing the hierarchy created by these declarations.
    </p>
  </statement>
      <response />
    </exercise>
             <exercise label="jinx_select legal statements">
      <title>Animal Hierarchy Java Code</title>       
 <statement>

    <p>
      Given the preceding hierarchy of classes,
      which of the following are legal assignment statements?

<program language="java">
<input>
DairyCow dc = new FarmAnimal();
FarmAnimal fa = new Goat();
Cow c1 = new DomesticAnimal();
Cow c2 = new DairyCow();
DomesticAnimal dom = new HousePet();
</input>
</program>
</p>
</statement>
      <response />
    </exercise>
           <exercise label="jinx_tracing_some_frame">
      <title>Tracing SomeFrame</title>       
 <statement>

<p>
The JFrame that follows contains a semantic error in its <c>SomeFrame()</c> constructor.
  The error will cause the <c>actionPerformed()</c> method never to display
  <q>Clicked</q> even though the user clicks the button in the JFrame.
  Why? (<em>Hint</em>: Think scope!)
</p>
<program language="java">
<input>
public class SomeFrame extends JFrame
                implements ActionListener
{
  // Declare instance variables
  private JButton button;
  public JFrame()
  {
    // Instantiate the instance variable
    JButton button = new JButton("Click me");
    add(button);
    button.addActionListener(this);
  } // init()
  public void actionPerformed(ActionEvent e)
  {
    if (e.getSource() == button)
      System.out.println("Clicked");
  } // actionPerformed()
} // SomeFrame
</input>
</program>
</statement>
      <response />
    </exercise>
           <exercise label="jinx_trace_some_frame_2">
      <title>Trace SomeFrame2</title>       
 <statement>

<p>
  What would be output by the following program?

<program language="java">
<input>
public class SomeFrame2 extends JFrame
{
  // Declare instance variables
  private JButton button;
  private JTextField field;
  public SomeFrame()
  {
    // Instantiate instance variables
    button = new JButton("Click me");
    add(button);
    field = new JTextField("Field me");
    add(field);
    System.out.println(field.getText() + button.getText());
  } // init()
  public static void main(String[] args) {
    SomeFrame2 frame = new SomeFrame2();
    frame.setSize(400,400);
    frame.setVisible(true);
  }
} // SomeFrame2
</input>
</program>

</p>
</statement>
      <response />
    </exercise>
           <exercise label="jinx_code_gui_parts">
      <title>GUI Parts and their String Representations</title>       
 <statement>


 <p>
  Design and implement a GUI that has a <c>JButton</c>, a <c>JTextField</c>, and 
  a <c>JLabel</c>
  and then uses the <c>toString()</c> method to display each object's string representation.
</p>

</statement>
      <response />
    </exercise>
           <exercise label="jinx_code_toggle_doctor">
      <title>Toggle Doctor</title>       
 <statement>

<p>
  The <c>JButton</c> class inherits a <c>setText(String s)</c> from 
  its <c>AbstractButton()</c> superclass.
  Using that method,
  design and implement a GUI that has a single button labeled initially,
  <q>The Doctor is out.</q>
  Each time the button is clicked,
  it should toggle its label to,
  <q>The Doctor is in.</q>
  and vice versa.
</p></statement>
      <response />
    </exercise>
  </exercises>
</section>
