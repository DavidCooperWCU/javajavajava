<section><title>Chapter Summary</title>
    <subsection><title>Principles of Object-Oriented Design</title>
    <p>
    To conclude this chapter,
    it will be helpful to focus briefly on how the examples we've seen address the various
     object-oriented design (OOD) principles we set out at the beginning of the book.</p>
    <ul>
      <li><p><term>Divide-and-Conquer Principle:</term>
      Notice how all of the problems tackled in this chapter have been solved by 
      dividing them into several classes, with each of the classes divided into separate 
      methods. The very idea of a class hierarchy is an application of this principle. 
      </p></li>
      <li><p><term>Encapsulation Principle:</term> The superclasses in our designs,
<c>Cipher</c> and <c>TwoPlayerGame</c>, encapsulate those features of the class hierarchy 
that are shared by all objects in the hierarchy. The subclasses, <c>CaesarCipher</c> 
and <c>OneRowNim</c>, encapsulate features that make them distinctive with the class 
hierarchy. Interface Principle. The several Java interfaces we've designed, 
<c>IPlayer</c>, <c>CLUIPlayableGame</c> and <c>UserInterface</c>, specify clearly how 
various types of related objects will interact with each other through the methods 
contained in the interfaces. Clean interfaces make for clear communication among objects. 
</p></li>
<li><p><term>Information Hiding Principle:</term> We have continued to make consistent use of
     the <c>private</c> and <c>public</c> qualifiers, and have now introduced the <c>protected</c> qualifier 
to extend this concept. The inheritance mechanism gives subclasses access to protected and
 public elements of their superclasses. </p></li>
 <li><p><term>Generality Principle:</term> As you move down a well-designed class hierarchy, 
    you go from the more general to the more specific features of the objects involved. 
    The abstract <em>encode()</em> method specifies the general form that encoding will 
    take while the various implementations of this method in the subclasses provide the 
    specializations necessary to distinguish, say, Caesar encoding from Transpose encoding.
     Similarly, the abstract <c>makeAMove()</c> method in the <c>IPlayer</c> interface 
     provides a general format for a move in a two-player game, while its various 
     implementations provide the specializations that distinguish one game from another. 
     </p></li>
<li><p><term>Extensibility Principle:</term>Overriding inherited methods and implementing 
    abstract methods from either an abstract superclass or a Java interface provide several
     well-designed ways to extend the functionality in an existing class hierarchy. 
     Extending a class is a form of specialization of the features inherited from the 
     superclass. </p></li>
     
    <li><p><term>Abstraction Principle:</term> Designing a class hierarchy is an exercise in 
        abstraction, as the more general features of the objects involved are moved into 
        the superclasses. Similarly, designing a Java interface or an abstract superclass 
        method is a form of abstraction, whereby the signature of the method is distinguished
         from its various implementations.</p></li>
    </ul>

  <p>
    These, then,
    are some of the ways that the several examples we have considered and this chapter's discussion have contributed to a deepening of our understanding of object-oriented design.
  </p>
  </subsection>
  
   <subsection><title>Technical Terms</title>
   
    <tabular>
        <row><cell> abstract method</cell><cell>plaintext</cell></row>
        <row><cell>  actual type (dynamic type)</cell><cell>polymorphic method</cell></row>
       <row><cell>  ciphertext</cell><cell> polymorphism</cell></row>
    <row><cell> class inheritance</cell><cell> static binding (early binding)</cell></row>
    <row><cell> cryptography</cell><cell>static type (declared type)</cell></row>
    <row><cell> dynamic binding (late binding)</cell><cell>substitution cipher</cell></row>
   <row><cell> interface</cell><cell>    transposition cipher</cell></row>
       <row><cell> overloaded method</cell></row>
             </tabular>
</subsection>

<subsection><title>Summary of Important Points</title>
    <ul>
      <li>
        <p>
          Inheritance is an object-oriented mechanism whereby subclasses inherit the public and protected instance variables and methods from their superclasses.
        </p>
      </li>
      <li>
        <p>
          Dynamic binding
          (or late binding)
          is the mechanism by which a method call is bound to
          (associated with)
          the correct implementation of the method at run time.
          In Java, all method calls,
          except for <c>final</c> or <c>private</c> methods,
          are resolved using dynamic binding.
        </p>
      </li>
      <li>
        <p>
          Static binding
          (or early binding)
          is the association of a method call with its corresponding implementation at compile time.
        </p>
      </li>
      <li>
        <p>
          Polymorphism is an object-oriented language feature in which a method call can lead to different actions depending on the object on which it is invoked.
          A polymorphic method is a method signature that is given different implementation by different classes in a class hierarchy.
        </p>
      </li>
      <li>
        <p>
          A static type is a variable's declared type.
          A dynamic type, or actual type,
          is the type of object assigned to that variable at a given point in a running program.
        </p>
      </li>
      <li>
        <p>
          An <c>abstract</c> method is a method definition that lacks an implementation.
          An <c>abstract</c> class is one that contains one or more <c>abstract</c> methods.
          An <c>abstract</c> class can be subclassed but not instantiated.
        </p>
      </li>
      <li>
        <p>
          A Java interface is a class that contains only method signatures and (possibly) constant declarations,
          but no variables.
          An interface can be implemented by a class by providing implementations for all of its abstract methods.
        </p>
      </li>
    </ul>
    
</subsection>

<solutions scope="chapter-inheritance" divisional="solution" project="solution" inline="solution">
  <title>Solutions to Self-Study Exercises</title>
</solutions>


<!-- 
    <subsection><title>Solutions to Self-Study Exercises</title>
    <ol>
      <li>
        <p>
          Running the <c>TestPrint</c> program will produce the output shown here.
          It is clear that the inherited <c>toString()</c> method is used by 
          <c>println()</c> when printing a <c>TestPrint</c> object.
 <program language="java"><input>
56.0
 TestPrint@be2d65
 </input></program>
        </p>
      </li>
      <li>
        <p>
          If you override the <c>toString()</c> method in <c>TestPrint</c>, you should get something like the output shown here,
          depending on how you code <c>toString()</c>. It is clear that the <c>toString()</c> method is used polymorphously by <c>println()</c>.
 <program language="java"><input>
56.0
 Hello from TestPrint
 </input></program>
        </p>
      </li>
      <li>
        <p>
          The output produced when constructing objects of type <em>A</em>
          and <c>B</c> in the order shown in the exercise would be as follows,
          with each letter occurring on a separate line:
 <program language="java"><input>
A B B
 </input></program>
        </p>
      </li>
      <li>
        <p>
          The new implementation of <c>B</c>'s <c>method()</c> will invoke <c>A</c>'s version of the method before printing <em>B</em>.
          This will print
          <q>A A B A B</q>.
 <program language="java"><input>
void method () {
     super.method();
     System.out.println("B");
 }
 </input></program>
        </p>
      </li>
      <li>
        <p>
          Give the definitions of classes <c>A</c> and <c>B</c> in the exercise,
          the marked statements would be invalid:
 <program language="java"><input>
A a = new B();   // Valid a B is an A
a = new A();     // Ok
B b = new A();   // Invalid. An A is not necessarily a B
b = new B();     // OK
 </input></program>
        </p>
      </li>
      <li>
        <p>
          Given the class definitions and code segment in this exercise,
          the output would be, <c>A A B A B C</c>, with each letter printing on a separate line.
        </p>
      </li>
      <li>
        <p>
          Definition of an <c>Pig</c> subclass of <c>Animal</c>:
 <program language="java"><input>
public class Pig extends Animal {
    public Pig() {
        kind = "pig";
    }
    public String speak() {
        return "oink";
    }}
 </input></program>
        </p>
      </li>
      <li>
        <p>
          If polymorphism was not used in our design,
          the <c>talk()</c> method would have to be modified to the following in order to accommodate a <c>Pig</c> subclass:
 <program language="java"><input>
public String talk(Animal a) {
  if (a instanceof Cow)
     return "I am a " + kind + " and I go " + a.moo();
   else if (a instanceof Cat)
     return "I am a " + kind + " and I go " + a.meow();
   else if (a instanceof Pig)
     return "I am a " + kind + " and I go " + a.oink();
   else
     return "I don't know what I am";}
 </input></program>
        </p>
      </li>
      <li>
        <p>
          Code to swap two <c>boolean</c> variables:
 <program language="java"><input>
boolean temp = b1; // Save b1's value
 b1 = b2;           // Change b1 to b2
 b2 = temp;         // Change b2 to b1's original value
 </input></program>
        </p>
      </li>
      <li>
        <p>
          Creating a <c>ToggleButton</c> that can be used to deal or collect cards:
 <program language="java"><input>
private ToggleButton dealer =
            new ToggleButton("deal","collect");
 add(dealer);
 dealer.addActionListener(this);
 </input></program>
        </p>
      </li>
      <li>
        <p>
          Modify the <c>Caesar</c> class so that it will allow various-sized shifts to be used.
 <program language="java"><input>
private int shift;
public void setShift(int n) { shift = n;    }
public int getShift()       { return shift; }
// Modification to encode():
ch = (char)('a' + (ch -'a'+ shift) % 26); // Shift
// Modification to decode():
ch = (char)('a' + (ch -'a'+ (26-shift)) % 26); // Shift
 </input></program>
        </p>
      </li>
      <li>
        <p>
          Modify <c>Transpose.encode()</c> so that it uses a rotation instead of a reversal.
          The operation here is very similar to the shift operation in the Caesar cipher.
          It uses modular arithmetic to rearrange the letters in the word.
          For example, suppose the word is
          <q>hello</q>. Its letters are indexed from 0 to 4.
          The following table shows how the expression <c>((k+2) % 5)</c> will rearrange the letters as <em>k</em>
          varies from 0 to 4:
 <program language="java"><input>
k  charAt(k)  (k+2) % 5   charAt((k+2) % 5)
    0  'h'          2          'l'
    1  'e'          3          'l'
    2  'l'          4          'o'
    3  'l'          0          'h'
    4  'o'          1          'e'
// Modification to encode():
public String encode(String word) {
    StringBuffer result = new StringBuffer();
    for (int k=0; k &lt; word.length(); k++)
        result.append(word.charAt((k+2) % word.length()));
    return result.toString();}
 </input></program>
        </p>
      </li>
      <li>
        <p>
          A <c>NimPlayer</c> class that plays the optimal <c>OneRowNim</c> game would be identical to the <c>NimPlayerBad</c> class except the <c>move():int</c> method would be replaced with the following implementation:
 <program language="java"><input>
public int move() {
    int sticksLeft = game.getSticks();
    if (sticksLeft % (game.MAX_PICKUP + 1) != 1)
        return (sticksLeft - 1) % (game.MAX_PICKUP +1);
    else {
        int maxPickup = Math.min(game.MAX_PICKUP, sticksLeft);
         return 1 + (int)(Math.random() * maxPickup);
    }
 }
 </input></program>
        </p>
      </li>
      </ol>

      
    </subsection>
  -->
</section>