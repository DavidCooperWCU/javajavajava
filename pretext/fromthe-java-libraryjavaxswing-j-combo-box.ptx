<section xml:id="fromthe-java-libraryjavaxswing-j-combo-box">
  <title>From the Java Library:
  javax.swing.JComboBox</title>
  <introduction>
    <p>
      \tBOXseven{A}<c>JComboBox</c> is a Swing component that combines a text field and a drop-down list (Fig.<nbsp/>12.28).
      It lets the user either type in a selection or choose a selection from a list that appears when the user requests it<mdash/>a <c>JComboBox</c>'s drop-down behavior is somewhat similar to a <c>java.awt.Choice</c> box.
    </p>
    <p>
      <image width="73%" source="chptr12/jcombobox.png"/>
    </p>
    <p>
      A <c>JComboBox</c> can be used to represent a
      <em>drop-down menu</em>.
      When the user clicks on a <c>JComboBox</c>, a list of options drops down,
      and the user can select a particular option that is stored in the box's internal state (Fig.<nbsp/>12.29).
      The list of options associated with a <c>JComboBox</c> can be built beforehand and inserted into the component in a constructor,
      or items can be inserted one at a time by repeatedly using its <c>addItem()</c> method.
    </p>
    <p>
      As Figure<nbsp/>12.28 shows,
      either an array or a vector of items can be passed to a constructor method to initialize the box's menu.
      The items stored in a <c>JComboBox</c> box are references to
<c>Object</c> s, most commonly <c>String</c> s that represent the name of the menu item.
      They are stored in the
      (zero indexed)
      order in which they are added.
      The <c>addItem()</c> method is used to add an individual
<c>Object</c> to a <c>JComboBox</c>. By default,
      the first item added to a <c>JComboBox</c> will be the <em>selected</em>
      item until the user selects another item.
    </p>
    <p>
      When the user makes a selection in a <c>JComboBox</c>, the item selected can be gotten either by its reference (<c>getSelectedItem()</c>) or by its position within the menu (<c>getSelectedIndex()</c>).
      There are also methods to <c>setSelectedItem()</c> and <c>setSelectedIndex()</c> that let you select an individual item either by its reference or its position.
      The <c>addItemListener()</c> method is used to designate some object as the listener for the <c>ItemEvent</c> s that are generated whenever the user selects a menu option.
      Alternatively,
      the addActionListener() method lets you handle action events,
      such as when the user types a value into the box.
    </p>
  </introduction>
  <subsection xml:id="fig-comboscreen">
    <title>A <c>JComboBox</c>Example</title>
    <p>
      As a simple example,
      let's design an graphical interface that can be used to display the fractal patterns we developed earlier.
      We want an interface that lets the user select from among the available patterns<mdash/>we'll use the Sierpinski gasket and nested boxes for starters.
      In addition,
      the user should also be able to select different levels for the drawings,
      from 0 to 9.
      We want to present these options in two menus,
      with one <c>JComboBox</c> for each menu.
    </p>
    <p>
      The first step is to declare and instantiate the <c>JComboBox</c> es as instance variables:
    </p>
 <program language="java"><input>
private String items[] =
    {"Sierpinski Gasket","Nested Boxes"};
private JComboBox patterns = new JComboBox(items);
private JComboBox levels = new JComboBox();
 </input></program>
    <p>
      Note that in this case we pass the constructor for the <image width="73%" source="chptr12/comboscreen.png"/> <c>patterns</c> menu an entire array of items.
      If we hadn't done it this way,
      we would add individual items to the combo box in the JFrame's constructor <c>RecursivePatterns()</c>. In fact,
      that's how we'll initialize the <c>levels</c> menu:
    </p>
 <program language="java"><input>
for (int k=0; k &lt; 10; k++)   // Add 10 levels
    levels.addItem(k + "" );
levels.setSelectedItem("4"); // Select default level
 </input></program>
    <p>
      This loop would be placed in the JFrame's constructor, <c> RecursivePatterns()</c>. It adds strings representing levels 0 to 9 to the menu and initializes the box so that level four is showing as the default option.
    </p>
    <p>
      Our next step is to designate the JFrame as the <c>ItemListener</c> for both menus<mdash/>that is,
      the JFrame is named as the object that will handle the events that occur in the <c>JComboBox</c> es.
      Then we add the
<c>JComboBox</c> component to the JFrame:
    </p>
 <program language="java"><input>
controls.add(levels);    // Control panel for menus
controls.add(patterns);
                                // Add the controls
getContentPane().add(controls, "North");
                           // And the drawing panel
getContentPane().add(canvas, "Center");
              // Register the menus with a listener
levels.addItemListener(this);
patterns.addItemListener(this);
 </input></program>
    <p>
      Note that we use a separate <c>controls</c> panel (a <c>JPanel</c>) for the two menus and a <c>canvas</c> panel (another <c>JPanel</c>) for the drawings.
    </p>
    <p>
      The next step is to implement the <c>itemStateChanged()</c> method to handle the user's selections.
      Whenever the user selects an item from a <c>JComboBox</c> menu,
      an <c>ItemEvent</c> is generated.
      In order to handle these events,
      the program must implement the <c>ItemListener</c> interface,
          <idx><h>ItemListener interface</h></idx>
      which consists of the single method <c>itemStateChanged()</c>. This method is invoked automatically whenever the user selects an item from one of the <c>JComboBox</c> es:
    </p>
 <program language="java"><input>
public void itemStateChanged(ItemEvent e) {
    canvas.setPattern(patterns.getSelectedIndex(),
                         levels.getSelectedIndex());
    repaint();}
 </input></program>
    <p>
      The <c>itemStateChanged()</c> method has the same general form as the <c>actionPerformed()</c> method,
      except that its parameter is an ItemEvent . For this example,
      the program uses the
<c>getSelectedIndex()</c> method to get the selected pattern and the selected level by their respective item numbers within the menus.
      It then passes these values along to the <c>canvas</c> object,
      which takes care of the drawing.
      Finally, the method invokes the <c>repaint()</c> method.
      Because the JFrame is a container,
      this will cause all of its components to be repainted as well.
    </p>
    <p>
      <xref ref="fig-seqdiag">Figure</xref>
      illustrates the sequence of events that occurs when an item is selected from a <c>JComboBox</c>. The complete implementation for the program is given in <xref ref="fig-recursivepatterns">Figure</xref>.
    </p>
    <figure xml:id="fig-seqdiag">
      <caption>This UML sequence diagram shows the interaction between
      the various objects included in the action of selecting an item
      from a <c>JComboBox</c>.</caption>
      <image width="73%" source="chptr12/seqdiag.png"/>
    </figure>
    <figure xml:id="fig-recursivepatterns">
      <caption>The <c>RecursivePatterns</c> program.</caption>
 <program language="java"><input>
import java.awt.*;
import javax.swing.*;
import java.awt.event.*;
public class RecursivePatterns extends JFrame implements ItemListener  {
  private String choices[] = {"Sierpinski Gasket", "Nested Boxes"};
  private JComboBox patterns = new JComboBox(choices); // Pattern choices
  private JComboBox levels = new JComboBox();          // Level choices
  private Canvas canvas = new Canvas();                // Drawing panel
  private JPanel controls = new JPanel();
  public RecursivePatterns() {
    for (int k=0; k &lt; 10; k++)            // Add 10 levels
      levels.addItem(k + "" );
    patterns.setSelectedItem(choices[0]); // Initialize menus
    levels.setSelectedItem("4");
    canvas.setBorder(BorderFactory.createTitledBorder("Drawing Canvas"));
    controls.add(levels);         // Control panel for menus
    controls.add(patterns);
    getContentPane().add(controls,"North"); // Add controls
    getContentPane().add(canvas,"Center");  // Add drawing panel
    levels.addItemListener(this);   // Register menus with listener
    patterns.addItemListener(this);
    setSize(canvas.WIDTH,canvas.HEIGHT+controls.getSize().width);
  } // init()
  public void itemStateChanged(ItemEvent e) {
    canvas.setPattern(patterns.getSelectedIndex(),
                                     levels.getSelectedIndex());
    repaint();                             // Repaint the JFrame
  } // itemStateChanged()
   public static void main(String args[])
   {
      JFrame f = new RecursivePatterns();
      f.setVisible(true);
   }} // RecursivePatterns
 </input></program>
    </figure>
    <figure xml:id="fig-canvas">
      <caption>Design of a drawing <c>Canvas</c> class.</caption>
      <image width="73%" source="chptr12/canvasnew.png"/>
    </figure>
    <p>
      The actual drawing of the fractal patterns is handled by the <c>canvas JPanel</c> component,
      whose design is shown in <xref ref="fig-canvas">Figure</xref>
      and whose implementation is given in <xref ref="fig-canvaspanel">Figure</xref>.
      All of the drawing is done in the <c>paintComponent()</c> method.
      Because the <c>canvas</c> is contained within the JFrame,
      the <c>paintComponent()</c> method is called automatically whenever the JFrame repaints itself.
      Notice how the
<c>switch</c> statement uses the pattern that  the user chose to call the corresponding drawing method.
      You can see from this <c>switch</c> statement that a <c>JComboBox</c>'s items are <em>zero indexed</em>.
    </p>
    <figure xml:id="fig-canvaspanel">
      <caption>The <c>Canvas</c> class is a drawing panel, Part I.</caption>
 <program language="java"><input>
import javax.swing.*;
import java.awt.*;
public class Canvas extends JPanel {
  private static final int GASKET = 0, BOXES = 1;
  public static final int WIDTH=400, HEIGHT=400;
  private final int HBOX=10, VBOX=50, BOXSIDE=200, BOXDELTA=10;
  private final int gP1X = 10;  private final int gP1Y = 280; // Initial
  private final int gP2X = 290; private final int gP2Y = 280; // gasket
  private final int gP3X = 150; private final int gP3Y = 110; // points
  private int pattern = 0 ;                      // Current pattern
  private int level = 4;                         // Current level
  public Canvas() {
    setSize(WIDTH, HEIGHT);
  }
  public void setPattern(int pat, int lev) {
    pattern = pat;
    level = lev;
  }
 </input></program>
    </figure>
    <figure xml:id="fig_canvaspart2">
      <caption>The <c>Canvas</c> class, Part II.</caption>
      
 <program language="java"><input>
public void paintComponent(Graphics g) {
        g.setColor(getBackground());   // Redraw the panel's background
        g.drawRect(0, 0, WIDTH, HEIGHT);
        g.setColor(getForeground());
        switch (pattern) {
        case GASKET:
            drawGasket(g, level, gP1X, gP1Y, gP2X, gP2Y, gP3X, gP3Y);
            break;
        case BOXES:
            drawBoxes(g, level, HBOX, VBOX, BOXSIDE, BOXDELTA );
            break;
        } // switch
    } // paintComponent()
   /** drawGasket()---recursively draws the Sierpinski
    *  gasket pattern, with points (p1X, p1Y), (p2X, p2Y), (p3X, p3Y)
    *  representing the vertices of its enclosing triangle.
    * level (>= 0) is the recursion parameter (base case: level  0)
    */
    private void drawGasket(Graphics g, int lev, int p1X, int p1Y,
                   int p2X, int p2Y, int p3X, int p3Y) {
        g.drawLine(p1X, p1Y, p2X, p2Y);  // Draw a triangle
        g.drawLine(p2X, p2Y, p3X, p3Y);
        g.drawLine(p3X, p3Y, p1X, p1Y);
        if (lev > 0) { // If more levels, draw 3 smaller gaskets
            int q1X = (p1X + p2X) / 2;    int q1Y = (p1Y + p2Y) / 2;
            int q2X = (p1X + p3X) / 2;    int q2Y = (p1Y + p3Y) / 2;
            int q3X = (p2X + p3X) / 2;    int q3Y = (p2Y + p3Y) / 2;
            drawGasket(g, lev - 1, p1X, p1Y, q1X, q1Y, q2X, q2Y);
            drawGasket(g, lev - 1, p2X, p2Y, q1X, q1Y, q3X, q3Y);
            drawGasket(g, lev - 1, p3X, p3Y, q2X, q2Y, q3X, q3Y);
        }
    } // drawGasket()
   /** drawBoxes()---recursively draws pattern of nested squares
    *  with (locX, locY) the top left corner of outer the square and
    *  side being the length square's side.
    * level (>= 0) is the recursion parameter (base case: level  0)
    * delta is used to adjust the length of the side.
    */
    private void drawBoxes(Graphics g, int level,
           int locX, int locY, int side, int delta) {
        g.drawRect(locX, locY, side, side );
        if (level > 0) {
            int newLocX = locX + delta; int newLocY = locY + delta;
            drawBoxes(g, level - 1, newLocX, newLocY,
                                          side - 2 * delta, delta);
        }
    } // drawBoxes()} // Canvas
 </input></program>
    </figure>
    <p>
      \secSMHleft{Chapter Summary} \secKTH{Technical Terms} \begin{KT} base case
    </p>
    <p>
      computational overhead
    </p>
    <p>
      head-and-tail algorithm
    </p>
    <p>
      iterative method
    </p>
    <p>
      last-in-first-out (LIFO)
    </p>
    <p>
      method call stack
    </p>
    <p>
      recursion parameter
    </p>
    <p>
      recursive case
    </p>
    <p>
      recursive definition
    </p>
    <p>
      recursive method
    </p>
    <p>
      self-similarity
    </p>
    <p>
      tail recursive
    </p>
    <p>
      \end{KT}
    </p>
    <p>
      \secSMHtwo{Summary of Important Points}
      <ul>
        <li>
          <p>
            A <em>recursive definition</em>
            is one that defines the <em>n</em>th case of a concept in terms of the <m>(n-1)</m>st case plus a limiting condition.
            It is based on the idea of breaking a problem up into smaller,
            self-similar problems.
          </p>
        </li>
        <li>
          <p>
            A <em>recursive
              <idx><h>recursive method</h></idx>
            method</em> is one that calls itself.
            It is usually defined in terms of a
            <em>base case</em> or limiting case,
            which stops the recursive process, and a recursive case,
            which breaks the method into a smaller,
            self-similar copy of itself.
            A <em>recursion parameter</em> is generally used to control the recursion.
          </p>
        </li>
        <li>
          <p>
            An iterative algorithm is one that uses some kind of loop as its control structure.
            Any algorithm that can be done iteratively can also be done recursively,
            and vice versa.
          </p>
        </li>
        <li>
          <p>
            Because method calling is relatively costly both in terms of memory used and CPU time involved,
            a recursive algorithm is generally less efficient than an iterative one that does the same thing.
          </p>
        </li>
        <li>
          <p>
            In designing recursive algorithms,
            the <em>base case</em> defines a limit.
            Each level of recursion should make progress toward the limit,
            and the algorithm should eventually reach the limit.
            The limit is usually expressed in terms of the
            <em>recursion parameter</em>.
          </p>
        </li>
        <li>
          <p>
            A recursive method is <em>tail recursive</em>
            if and only if each of its recursive calls is the last action executed by the method.
          </p>
        </li>
        <li>
          <p>
            A Swing <c>JComboBox</c> component is used to represent a GUI drop-down menu.
          </p>
        </li>
      </ul>
    </p>
    <p>
      \secANSHleft
      <ul>
        <li>
          <p>
            The output produced by <c>mystery(0)</c> would be 0 1 2 3 4 5 6.
            The output produced by <c>mystery(100)</c> would be 100.
          </p>
        </li>
        <li>
          <p>
            The output produced by <c>mystery(5)</c> would be: 5 4 3, and so on.
            In other words, this is an infinite recursion.
          </p>
        </li>
        <li>
          <p>
             <program language="java"><input>
Definition: twoToN(N), N >= 0
  1, if N == 0                   // Base case
  2 * twoToN(N - 1),  N > 0      // Recursive case
 </input></program>
          </p>
        </li>
        <li>
          <p>
            The function <m>x^n</m> is known as the power function:
 <program language="java"><input>
Definition: power(X,N), N >= 0
  1, if N == 0                    // Base case
  X * power(X, N - 1),  N > 0     // Recursive case
 </input></program>
          </p>
        </li>
        <li>
          <p>
            Yes, the two definitions for nested boxes are equivalent.
            Suppose the square starts out with a side of 20.
            The definition given in the exercise will also draw squares with sides of 20, 15, 10, 5.
          </p>
        </li>
        <li>
          <p>
            A recursive definition for the pattern in Figure<nbsp/>12.4:
 <program language="java"><input>
Draw a square with side, s.
Inscribe a circle with diameter, s.
If s > 5,
  Draw a smaller version of same pattern. // Recursive case
 </input></program>
          </p>
        </li>
        <li>
          <p>
            The <c>printString2("hello")</c> method will print:
            <q>olleh.</q>
          </p>
        </li>
        <li>
          <p>
            A definition for <c>countDown()</c>:
 <program language="java"><input>
/** countDown(N) recursively prints a countdown
  *  beginning at N and ending at 1
  * @param N >= 1
  * Base case: N == 0
  */
void countDown(int N) {
    if (N == 0)                     // Base case
        System.out.println("blastoff");
    else {
        System.out.print(N + ", "); // Recursive case
        countDown(N - 1);
    }} // countDown()
 </input></program>
          </p>
        </li>
        <li>
          <p>
            A revised definition for <c>countDown()</c>:
 <program language="java"><input>
/** countDown(N) recursively prints a countdown
  *  beginning at N, counting every other number, 10 8 6 ...
  *  and ending at "blastoff"
  * @param N >= 1
  * Base case: N &lt;= 0
  */
void countDown(int N) {
    if (N &lt;= 0)                     // Base case
        System.out.println("blastoff");
    else {
        System.out.print(N + ", "); // Recursive case
        countDown(N - 2 );
    }} // countDown()
 </input></program>
          </p>
        </li>
        <li>
          <p>
            A method to sum the numbers from 1 to
            <em>N</em>.
 <program language="java"><input>
int sum(int N) {
    if (N == 0)
        return 0;
    else
        return N + sum(N-1);}
 </input></program>
          </p>
        </li>
        <li>
          <p>
            A method to change each blank within a string to two blanks.
 <program language="java"><input>
String addBlanks(String s) {
  if (s.length() == 0)
     return "";
  else if (s.charAt(0) == ' ')
     return ' ' + s.charAt(0) + addBlanks(s.substring(1));
  else
     return s.charAt(0) + addBlanks(s.substring(1));}
 </input></program>
          </p>
        </li>
        <li>
          <p>
            A method to print out all possible outcomes for a chess player playing <c>N</c> games. <c>printOutcomes(str, N)</c> will print all outcomes for the next <c>N</c> games given that results for previous games are stored in the string named <c>str</c>.
 <program language="java"><input>
public static void printOutcomes(String str, int N){
     if (N = 1){ // Base case: win, lose, or draw one game
         System.out.println(str + "W");
         System.out.println(str + "L");
         System.out.println(str + "D");
     } else {  // Recursive case
         printOutcomes(str + "W", N - 1);
         printOutcomes(str + "L", N - 1);
         printOutcomes(str + "D", N - 1);
     } //else
 }// printOutcomes()
 </input></program>
          </p>
        </li>
        <li>
          <p>
             <program language="java"><input>
public static void main(String args[]) {
  int numbers[] = {0, 2, 4, 6, 8, 10, 12, 14, 16, 18};
  Searcher searcher = new Searcher();
  for (int k = 0; k &lt;= 20; k++) {
    int result = searcher.search(numbers, k);
    if (result != -1)
      System.out.println(k + " found at " + result);
    else
      System.out.println(k + " is not in the array ");
  } // for} // main()
 </input></program>
          </p>
        </li>
        <li>
          <p>
            The <c>sort()</c> method is used as a public interface to the recursive <c>selectionSort()</c> method:
 <program language="java"><input>
/** sort(arr) sorts the int array, arr
 *  Pre: arr is not null
 *  Post: arr will be arranged so that arr[j] &lt;= arr[k]
 *     for any j &lt; k
 */
public void sort(int arr[]) {
    selectionSort(arr, arr.length - 1);
             // Just call the recursive method}
 </input></program>
          </p>
        </li>
        <li>
          <p>
            An iterative version of <c>findMax()</c>:
 <program language="java"><input>
/** findMax (arr,N) returns the index of the largest
  *  value between arr[0] and arr[N], N >= 0.
  *  Pre: 0 &lt;= N &lt;= arr.length -1
  *  Post: arr[findMax()]>=arr[k] for k between 0 and N.
  */
private int findMax(int arr[], int N) {
    int maxSoFar = 0;
    for (int k = 0; k &lt;= N; k++)
        if (arr[k] > arr[maxSoFar])
            maxSoFar = k;
    return maxSoFar;} // findMax()
 </input></program>\marginfiglarge{chptr12/boxes45.eps}{Levels four and five of the nested boxes pattern.}{fig-boxes45}
          </p>
        </li>
        <li>
          <p>
            Levels four and five of the nested boxes pattern are shown in Figure<nbsp/>12.34.
          </p>
        </li>
        <li>
          <p>
            The following method will reduce the length of the side by <c>delta</c> percent at each level of recursion.
            The spacing between the boxes will vary by a constantly decreasing amount.
 <program language="java"><input>
private void  drawBoxes(Graphics g, int level, int locX,
                   int locY, int side, int delta) {
    g.drawRect(locX, locY, side, side );
    if (level > 0) {
      int dside = side * delta / 100; // Percent delta
      int newLocX = locX + dside;
      int newLocY = locY + dside;
      drawBoxes(g, level - 1, newLocX, newLocY,
                         side - 2 * dside, delta);
    }} // drawBoxes()
 </input></program>
          </p>
        </li>
        <li>
          <p>
             <program language="java"><input>
private void drawBoxesIterative(Graphics g, int level,
            int locX, int locY, int side, int delta) {
 for (int k = level; k >= 0; k--) {
  g.drawRect(locX, locY, side, side );  // Draw a square
  locX += delta;             // Calculate new location
  locY += delta;
  side -= 2 * delta;         // Calculate new side length
 }} // drawBoxes()
 </input></program>
          </p>
        </li>
        <li>
          <p>
            The level two and three gaskets are shown in <xref ref="fig-sierpinski23">Figure</xref>.
            <figure xml:id="fig-sierpinski23">
              <caption>Levels two and three of the Sierpinski gasket.</caption>
              <image width="73%" source="chptr12/sierpinski23.png"/>
            </figure>
          </p>
        </li>
        <li>
          <p>
            The <c>printReverse()</c> method is not tail recursive because in that method the recursive call is not the last statement executed.
          </p>
        </li>
        <li>
          <p>
            The <c>countChar()</c> method is tail recursive.
            The recursive calls are not the last statements in the method definition.
            However, each of the recursive calls would be the last statement executed by the method.
          </p>
        </li>
      </ul>
    </p>
    <p>
      {\rule[0pt]{40.5pc}{0.5pt}} \epsfig{file=../commonart/eoc2text.eps,
      height=4pt,width=40.5pc,clip=}  } }
    </p>
    <ol>
      <li>
        <p>
          Explain the difference between the following pairs of terms:
        </p>
        <ol>
          Iteration and <em>recursion</em>. Recursive method and <em>recursive definition</em>. Base case and <em>recursive case</em>. Head and <em>tail</em>. Tail and <em>nontail</em> recursive.
        </ol>
        \marginpar{<term>Note:</term> For programming exercises,
        <term>first</term> draw a UML class diagram describing all classes and their inheritance relationships and/or associations.}
      </li>
      <li>
        <p>
          Describe how the <em>method call stack</em>
          is used during a method call and return.
        </p>
      </li>
      <li>
        <p>
          Why is a recursive algorithm generally less efficient than an iterative algorithm?
        </p>
      </li>
      <li>
        <p>
          A tree, such as a maple tree or pine tree,
          has a recursive structure.
          Describe how a tree's structure displays
          <em>self-similarity</em>
          and <em>divisibility</em>.
        </p>
      </li>
      <li>
        <p>
          Write a recursive method to print each element of an array of <c>double</c>.
        </p>
      </li>
      <li>
        <p>
          Write a recursive method to print each element of an array of <c>double</c> from the last to the first element.
        </p>
      </li>
      <li>
        <p>
          Write a recursive method that will concatenate the elements of an array of <c>String</c> into a single <c>String</c> delimited by blanks.
        </p>
      </li>
      <li>
        <p>
          Write a recursive method that is passed a single <c>int</c> parameter,
          <m>N \geq 0</m>,
          and prints all the odd numbers between 1 and <em>N</em>.
        </p>
      </li>
      <li>
        <p>
          Write a recursive method that takes a single <c>int</c> parameter <m>N \geq 0</m> and prints the sequence of even numbers between <em>N</em> down to 0.
        </p>
      </li>
      <li>
        <p>
          Write a recursive method that takes a single <c>int</c> parameter
          <m>N \geq 0</m> and prints the multiples of 10 between 0 and <em>N</em>.
        </p>
      </li>
      <li>
        <p>
          Write a recursive method to print the following geometric pattern:
 <program language="java"><input>
#
# #
# # #
# # # #
# # # # #
 </input></program>
        </p>
      </li>
      <li>
        <p>
          Write recursive methods to print each of the following patterns.
 <program language="java"><input>
# # # # # # # #     # # # # # # # #
  # # # # # # #     # # # # # # #
    # # # # # #     # # # # # #
      # # # # #     # # # # #
        # # # #     # # # #
          # # #     # # #
            # #     # #
              #     #
 </input></program>
        </p>
      </li>
      <li>
        <p>
          Write a recursive method to print all multiples of <em>M</em>
          up to <em>M</em> * <em>N</em>.
        </p>
      </li>
      <li>
        <p>
          Write a recursive method to compute the sum of grades stored in an array.
        </p>
      </li>
      <li>
        <p>
          Write a recursive method to count the occurrences of a substring within a string.
        </p>
      </li>
      <li>
        <p>
          Write a recursive method to remove the HTML tags from a string.
        </p>
      </li>
      <li>
        <p>
          Implement a recursive version of the <c>Caesar.decode()</c> method from Chapter<nbsp/>8.
        </p>
      </li>
      <li>
        <p>
          The Fibonacci
            <idx><h>Fibonacci sequence</h></idx>
          sequence (named after the Italian mathematician Leonardo of Pisa,
          ca. 1200) consists of the numbers <c>0,1,1,2,3,5,8,13,<ellipsis /> </c> in which each number
          (except for the first two)
          is the sum of the two preceding numbers.
          Write a recursive method <c>fibonacci(N)</c> that prints the first
          <em>N</em> Fibonacci numbers.
        </p>
      </li>
      <li>
        <p>
          Write a recursive method to rotate a <c>String</c> by
          <em>N</em> characters to the right.
          For example, <c>rotateR("hello", 3)</c> should return
          <q>llohe.</q>
        </p>
      </li>
      <li>
        <p>
          Write a recursive method to rotate a <c>String</c> by
          <em>N</em> characters to the left.
          For example, <c>rotateL("hello", 3)</c> should return
          <q>lohel.</q>
        </p>
      </li>
      <li>
        <p>
          Write a recursive method to convert a <c>String</c> representing a binary number to its decimal equivalent.
          For example,
<c>binTodecimal("101011")</c> should return the <c>int</c> value 43.
        </p>
      </li>
      <li xml:id="fig-btree">
        <p>
          A palindrome is a string that is equal to its reverse<mdash/>
          <q>mom,</q>
          <q>i,</q>
          <q>radar</q>
          and
          <q>able was i ere i saw elba.</q>
          Write a recursive
<c>boolean</c> method that determines whether its <c>String</c> parameter is a palindrome.
          <image width="73%" source="chptr16/btree.png"/>  Challenge:  Incorporate a <c>drawBinaryTree()</c> method into the <c>RecursivePatterns</c> program.
          A level-one binary tree has two branches.
          At each subsequent level,
          two smaller branches are grown from the endpoints of every existing branch.
          The geometry is easier if you use 45-degree angles for the branches.
          Figure<nbsp/>12.36 shows a level-four binary tree drawn upside down.
          Challenge: Towers of Hanoi.
          According to legend,
          some Buddhist monks were given the task of moving 64 golden disks from one diamond needle to another needle,
          using a third needle as a backup.
          To begin with,
          the disks were stacked one on top of the other from largest to smallest (Fig.<nbsp/>12.37).
          The rules were that only one disk can be moved at a time and that a larger disk can never go on top of a smaller one.
          The end of the world was supposed to occur when the monks finished the task!
          Write a recursive method,
<c>move(int N, char A, char B, char C)</c>, that will print out directions the monks can use to solve the towers of Hanoi problem.
          For example,
          here's what it should output for the three-disk case,
<c>move(3, "A", "B", "C")</c>: <image width="73%" source="chptr12/hanoi.png"/> \caption{The towers of Hanoi problem.
          Move all the disks from needle A to needle B.<nbsp/>Only one disk can be moved at a time,
          and a larger disk can never go on top of a smaller one. }
 <program language="java"><input>
Move 1 disk from A to B.
Move 1 disk from A to C.
Move 1 disk from B to C.
Move 1 disk from A to B.
Move 1 disk from C to A.
Move 1 disk from C to B.
Move 1 disk from A to B.
 </input></program>
        </p>
      </li>
    </ol>
  </subsection>
</section>