<section xml:id="ch-methods-exs">
  <title>Exercises</title>
  
  <subsection><title>Matching Vocabulary</title>      
  <exercise label="matching-methods">
    <title>Matching Problem for Methods</title>
    <idx>matching method vocabulary</idx>
    <statement>
      <p>Match the vocabulary with their definitions.</p>
    </statement>
    <feedback>
      <p>Review the chapter vocabulary in the Summary.</p>
    </feedback>
    <matches>
      <match>
        <premise>method signature</premise>
        <response>A method's name, number, type, and order of parameters
        </response>
      </match>
      <match>
        <premise>constructor</premise>
        <response>A method that is invoked when an object is created</response>
      </match>
      <match>
        <premise>accessor (get) method</premise>
        <response>A method whose purpose is to provide access to an object's instance variables</response>
      </match>
      <match>
        <premise>mutator (set) method</premise>
        <response>A method whose purpose is to change an object's instance variables</response>
      </match>
      <match>
        <premise>void</premise>
        <response>The return type for a method that returns no value</response>
      </match>
      
    </matches>
  </exercise>

  <exercise label="matching-methods2">
    <title>Matching Problem for Inheritance</title>
    <statement>
      <p>Match the vocabulary with their definitions.</p>
    </statement>
    <feedback>
      <p>Review the chapter vocabulary in the Summary.</p>
    </feedback>
    <matches>
      <match>
        <premise>inheritance</premise>
        <response>Allows the use of a superclass method in a subclass</response>
      </match>  
      <match>
        <premise>method overidding</premise>
        <response>Redefining a superclass method in a subclass</response>
      </match>
      <match>
	<premise>method overloading</premise>
	<response>Giving the same name (but different number or types of parameters) to two or more methods
	</response>
      </match> 
      
    </matches>
  </exercise>

  <exercise label="matching-scope">
    <title>Matching Problem for Scope and Access</title>
    <statement>
      <p>Match the vocabulary with their definitions.</p>
    </statement>
    <feedback>
      <p>Review the chapter summary.</p>
    </feedback>
    <matches>
      <match>
        <premise>local scope</premise>
        <response>A method's parameters have this scope</response>
      </match>
      <match>
        <premise>class scope</premise>
        <response>A class's instance variables have this scope</response>
      </match>
      <match>
        <premise>private</premise>
        <response>A class's instance variables should usually have this type of access.</response>
      </match>
      <match>
        <premise>public</premise>
        <response>The methods that make up an object's interface should have this type of access.</response>
      </match>
    </matches>
  </exercise>
  <exercise label="matching-ifs">
    <title>Matching Problem for Control Structures</title>
    <statement>
      <p>Match the vocabulary with their definitions.</p>
    </statement>
    <feedback>
      <p>Review the chapter summary.</p>
    </feedback>
    <matches>
      <match>
        <premise>selection statements</premise>
        <response>if statements and if-else statements</response>
      </match>
      <match>
        <premise>boolean</premise>
        <response>An expression that evaluates to either <c>true</c> or <c>false</c></response>
      </match>
      <match>
        <premise>the closest unmatched if in the same block of statements</premise>
        <response>an else clause matches with</response>
      </match>
    </matches>
  </exercise>
  </subsection>

  <subsection><title>Debugging Exercises</title>
  
  <p>
    Identify and fix the syntax errors in each of the following:
  </p>
  
  <exercise label="ifDebug1">
    <statement><p>Debug the following program.</p></statement>
    <program language="java" interactive='activecode'><input>
      public class Debug
      {
      public static void main (String argv[])
      {
      if (isWalking == true) ;
      System.out.println("Walking");
      else
      System.out.println("Not walking");
      }
      }
    </input></program>
  </exercise>
  
  <exercise label="ifDebug2">
    <statement><p>Debug the following program.</p></statement>
    <program language="java"  interactive='activecode'><input>
      public class Debug
      {
      public static void main (String argv[])
      {
      if (isWalking)
      System.out.println("Walking")
      else
      System.out.println("Not walking");
      }
      }
    </input></program>
  </exercise>
  
  <exercise label="ifDebug3">
    <statement><p>Debug the following program.</p></statement>
    <program language="java" xml:id="ifEx3" interactive='activecode'><input>
      public class Debug
      {
      public static void main (String argv[])
      {
      if (isWalking)
      System.out.println("Walking");
      else
      System.out.println("Not walking")
      }
      }
    </input></program>
  </exercise>
  
  <exercise label="ifDebug4">
    <statement><p>Debug the following program.</p></statement>
    <program language="java"  interactive='activecode'><input>
      public class Debug
      {
      public static void main (String argv[])
      {
      if (isWalking = false)
      System.out.println("Walking");
      else
      System.out.println("Not walking");
      }
      }
  </input></program></exercise>

  </subsection>

  <subsection><title>Programming Exercises</title>
  <p> 
    For programming exercises, first draw a UML class diagram describing all classes 
    and their inheritance relationships and/or associations.
  </p>
  
  <p>
    Explain the difference between the following pairs of concepts:
  </p>          
  <exercise label="jmex_method_parts_pair">
    <statement>
      <p> 
	<em>Parameter</em> and <em>argument</em>.                  
      </p>
    </statement>
    <response />
  </exercise>
  <exercise label="jmex_def_vs_invocation_pair">
    <statement>
      <p> 
	<em>Method definition</em> and <em>method invocation</em>.                  
      </p>
    </statement>
    <response />
  </exercise>
  <exercise label="jmex_local_vs_class_scope">
    <statement>
      <p> 
	<em>Local scope</em> and <em>class scope</em>.
      </p>
    </statement>
    <response />
  </exercise>
  <exercise label="jmex_primitive_vs_reference">
    <statement>
      <p> 
	<em>Primitive type</em> and <em>reference type</em>.                  
      </p>
    </statement>
    <response />
  </exercise>
  <exercise label="jmex_access_vs_constructor">
    <statement>
      <p> 
	<em>Access method</em> and <em>constructor method</em>.                  
      </p>
    </statement>
    <response />
  </exercise>
  <p>
    Translate each of the following into Java code:
  </p>
  
  
  <exercise label="jmex_code_if_else_1">
    <statement>
      <p>
        If b1 is true, then print
        <q>one</q>; otherwise, print
        <q>two</q>.
      </p>
    </statement>
    <response />
  </exercise>
  <exercise label="jmex_code_if_else_2">
    <statement>
      <p>
        If b1 is false and if b2 is true, then print
        <q>one</q>; otherwise, print
        <q>two</q>.
      </p>
    </statement>
    <response />
  </exercise>
  <exercise label="jmex_code_if_else_3">
    <statement>
      <p>
        If b1 is false then if b2 is true, then print
        <q>one</q>; otherwise, print
        <q>two</q>, otherwise print
        <q>three</q>.
      </p>
    </statement>
    <response />
  </exercise>
  
  
  <p>
    For each of the following,
    suppose that <c>isWalking</c> is <c>true</c> and <c>isTalking</c> is <c>false</c>
    (first draw a flowchart for each statement and then
    determine what would be printed by each statement):
  </p>
  
  <exercise label="jmex_trace_if_else_1">
    <statement>
      <p>
	<program language="java"><input>
	  if (isWalking == false)
	  System.out.println("One");
	  System.out.println("Two");
	</input></program>
      </p>
    </statement>
    <response />
  </exercise>
  <exercise label="jmex_trace_if_else_2">
    <statement>
      <p>
	<program language="java"><input>
	  if (isWalking == true)
	  System.out.println("One");
	  System.out.println("Two");
	</input></program>
      </p>
    </statement>
    <response />
  </exercise>
  <exercise label="jmex_trace_if_else_3">
    <statement>
      <p>
	<program language="java"><input>
	  if (isWalking == false)
	  {
	  System.out.println("One");
	  System.out.println("Two");
	  }
	</input></program>
      </p>
    </statement>
    <response />
  </exercise>
  <exercise label="jmex_trace_if_else_4">
    <statement>
      <p>
	<program language="java"><input>
	  if (isWalking == false)
	  if (isTalking == true)
	  System.out.println("One");
	  else
	  System.out.println("Two");
	  else
	  System.out.println("Three");
	</input></program>
      </p>
    </statement>
    <response />
  </exercise>
  
  <exercise label="jmex_trace_one_row_nim">
    <statement>
      <p>
	Show what the output would be if the following version of
	<c>main()</c> were executed:
	<program language="java"><input>
	  public static void main(String argv[])
	  {
	  System.out.println("main() is starting");
	  OneRowNim game1;
	  game1  = new OneRowNim(21);
	  OneRowNim game2;
	  game2 = new OneRowNim(8);
	  game1.takeSticks(3);
	  game2.takeSticks(2);
	  game1.takeSticks(1);
	  game1.report();
	  game2.report();
	  System.out.println("main() is finished");
	  }
	</input></program>
      </p>
    </statement>
    <response />
  </exercise>
  <exercise label="jmex_trace_mystery">
    <statement>
      <p>
	Determine the output of the following program:
	<program language="java"><input>
	  public class Mystery
	  {
	  public String myMethod(String s)
	  {
	  return("Hello" + s);
	  }
	  public static void main(String argv[])
	  {
	  Mystery mystery = new Mystery();
	  System.out.println( mystery.myMethod(" dolly");
	  }
	  }
	</input></program>
      </p>
    </statement>
    <response />
  </exercise>
  <exercise label="jmex_code_convert_method">
    <statement>
      <p>
	Write a <c>boolean</c> method<mdash/>a method that returns a <c>boolean</c><mdash/>that takes an <c>int</c> parameter and converts the integers 0 and 1 into <c>false</c> and <c>true</c>, respectively.
      </p>
    </statement>
    <response />
  </exercise>
  <exercise label="jmex_code_test_boolean_method">
    <statement>
      <p>
	Define an <c>int</c> method that takes a <c>boolean</c> parameter.
	If the parameter's value is <c>false</c>, the method should return 0;
	otherwise, it should return<nbsp/>1.
      </p>
    </statement>
    <response />
  </exercise>
  <exercise label="jmex_code_print_hello_goodbye_method">
    <statement>
      <p>
	Define a <c>void</c> method named <c>hello</c> that takes a single <c>boolean</c> parameter.
	The method should print
	<q>Hello</q>
	if its parameter is true; otherwise, it should print
	<q>Goodbye</q>.
      </p>
    </statement>
    <response />
  </exercise>
  <exercise label="jmex_code_return_hello_goodbye_method">
    <statement>
      <p>
	Define a method named <c>hello</c> that takes a single <c>boolean</c> parameter.
	The method should return
	<q>Hello</q>
	if its parameter is true; otherwise it should return
	<q>Goodbye</q>. Note the difference between this method and the one in the previous exercise.
	This one returns a <c>String</c>. That one was a <c>void</c> method.
      </p>
    </statement>
    <response />
  </exercise>
  <exercise label="jmex_code_return_hello_parameter_method">
    <statement>
      <p>
	Write a method named <c>hello</c> that takes a single <c>String</c> parameter.
	The method should return a <c>String</c> that consists of the word
	<q>Hello</q>
	concatenated with the value of its parameter.
	For example,
	if you call this method with the expression
	<c>hello("dolly")</c>, it should return
	<q>hello dolly</q>. If you call it with <c>hello("young lovers wherever you are")</c>, it should return
	<q>hello young lovers wherever you are</q>.
      </p>
    </statement>
    <response />
  </exercise>
  <exercise label="jmex_code_first_day_of_xmas">
    <statement>
      <p>
	Define a void method named <c>day1</c> that prints
	<q>a partridge in a pear tree</q>.
      </p>
    </statement>
    <response />
  </exercise>
  <exercise label="jmex_code_twelve_days_of_xmas">
    <statement>
      <p>
	Write a Java application program called <c>TwelveDays</c> that prints the Christmas carol
	<q>Twelve Days of Christmas.</q>
	For this version,
	write a void method named <c>intro()</c> that takes a single
	<c>String</c> parameter that gives the day of the verse and prints the intro to the song.
	For example, <c>intro("first")</c> should print,
	<q>On the first day of Christmas my true love gave to me</q>. Then write methods <c>day1()</c>, <c>day2()</c>, and so on,
	each of which prints its version of the verse.
	Then write a <c>main()</c> method that calls the other methods to print the whole song.
      </p>
    </statement>
    <program label="jmex_twelve_days_prg_main" language="java"
	       interactive="activecode"><input>
      public class TwelveDays {
          public static void main(String[] args) {

          }
	
      }
      </input>
      </program>

  </exercise>
  <exercise label="jmex_code_twelve_days_verse">
    <statement>
      <p>
	Define a <c>void</c> method named <c>verse</c> that takes two <c>String</c> parameters and returns a verse of the Christmas carol
	<q>Twelve Days of Christmas.</q>
	For example,
	if you call this method with <c>verse("first", "a  partridge in a pear tree")</c>, it should return,
	<q>On the first day of Christmas my true love gave to me, a partridge in a pear tree</q>.
      </p>
    </statement>
    <response />
  </exercise>
  <exercise label="jmex_code_permute_strings">
    <statement>
      <p>
	Define a <c>void</c> method named <c>permute</c>, which takes three <c>String</c> parameters and prints out all possible arrangements of the three strings.
	For example,
	if you called
	<c>permute("a", "b", "c")</c>, it would produce the following output:
	abc, acb, bac, bca, cab, cba,
	with each permutation on a separate line.
      </p>
    </statement>
    <response />
  </exercise>
  <exercise label="jmex_code_limerick">
    <statement>
      <p>
	Design a method that can produce limericks given a bunch of rhyming words.
	That is, create a limerick template that will take any five words or phrases and produce a limerick.
	For example,
	if you call
	<program language="java"><input>
	  limerick("Jones","stones","rained","pained","bones");
	  </input></program>your method might print (something better than)
	  <program language="java"><input>
	    There once a person named Jones
	    Who had a great liking for stones,
	    But whenever it rained,
	    Jones' expression was pained,
	    Because stones weren't good for the bones.
	  </input></program>
      </p>
    </statement>
    <response />
  </exercise>
  <exercise label="jmex_code_donor">
    <statement>
      <p>
	Define a class named <c>Donor</c> that has two instance variables,
	the donor's name and rating, both of which are <c>String</c> s.
	The name can be any string, but the rating should be one of the following values:
	<q>high,</q> <q>medium,</q> or <q>none.</q> Write the following methods for this class:
	a constructor, <c>Donor(String,String)</c>, that allows you to set both the donor's 
	name and rating; and access methods to get both the name and rating of a donor.
	Write a complete Java application program.
      </p>
    </statement>
          <program label="jmex_donor_class" language="java"
	       interactive="activecode"><input>
	public class Donor {

	}
      </input>
      	<tests>
          <![CDATA[
import static org.junit.Assert.*;
import org.junit.*;
import java.io.*;
import java.util.List;
import java.util.ArrayList;
import java.util.Arrays;
import java.lang.reflect.*;

public class RunestoneTests extends CodeTestHelper
{

    public RunestoneTests() {
	super("Donor");
    }


    private Object getTestInstance(Object[] defaultTestValues) {
        String errorMessage = "";
        try {
	    Class<?> c = Class.forName("Donor");
            Constructor[] ctors = c.getDeclaredConstructors();
            Constructor ctor = ctors[0];

	    return ctor.newInstance((Object[])null);

} catch (Exception e) {
try {
Class<?> c = Class.forName("Donor");
            Constructor[] ctors = c.getDeclaredConstructors();
            Constructor ctor = ctors[0];

return ctor.newInstance(defaultTestValues);
}catch (Exception e2) {
errorMessage = "Couldn't call constructor";
}
        }

        return null;
    }
    
    @Test
    public void test1()
    {
	String target = "2 Private";
	String actual = testPrivateInstanceVariables();
	expect(target,actual,"exactly 2 private field");
	
    }
    @Test
    public void test1b()
    {
	boolean found = true;
	String[] types = {"String", "String"};
	String fieldTypes =
	    testInstanceVariableTypes(types);
	if (fieldTypes.trim().equals("") || fieldTypes.equals("fail")) {
	    found = false;
	} else {
	    String[] typeNames = fieldTypes.trim().split(" ");
	    if(typeNames.length != 1 || !typeNames[0].equals("String")
	    || !typeNames[1].equals("String") ) {
		found = false;
	    }
	    if(types[0] != null || types[1] != null) {
		found = false;
	    }

	}

	expect(true,found,"has exactly 2 String fields");
    }

    @Test
    public void test2()
    {
    String name = "Max Money";
    String rating = "high";
    String value = name;
    String target = value;
    String methodName = "getName";
	try {
	    Object[] testValues = {name,rating};
	    Object t = getTestInstance(testValues);
	    Method m = t.getClass().getMethod(methodName);
	    int actual = (Integer) m.invoke(t);
	    expect(target,actual,
		   "constructor and " + methodName + "() work for " + value);
	} catch(Exception e) {
	    expect(String.valueOf(target),e.toString(),
		   "constructor and/or " +  methodName + "() don't work");
	}
	}
@Test
    public void test3()
    {
    String name = "Max Money";
    String rating = "high";
    String value = rating;
    String target = value;
    String methodName = "getRating";
	try {
	    Object[] testValues = {name,rating};
	    Object t = getTestInstance(testValues);
	    Method m = t.getClass().getMethod(methodName);
	    int actual = (Integer) m.invoke(t);
	    expect(target,actual,
		   "constructor and " + methodName + "() work for " + value);
	} catch(Exception e) {
	    expect(String.valueOf(target),e.toString(),
		   "constructor and/or " +  methodName + "() don't work");
	}
    }

    @Test
    public void test4()
    {
    String name = "Monarch Butterfly";
    String rating = "medium";
    String value = name;
    String target = value;
    String methodName = "getName";
	try {
	    Object[] testValues = {name,rating};
	    Object t = getTestInstance(testValues);
	    Method m = t.getClass().getMethod(methodName);
	    int actual = (Integer) m.invoke(t);
	    expect(target,actual,
		   "constructor and " + methodName + "() work for " + value);
	} catch(Exception e) {
	    expect(String.valueOf(target),e.toString(),
		   "constructor and/or " +  methodName + "() don't work");
	}
	}
@Test
    public void test5()
    {
    String name = "Monarch Butterfly";
    String rating = "medium";
    String value = rating;
    String target = value;
    String methodName = "getRating";
	try {
	    Object[] testValues = {name,rating};
	    Object t = getTestInstance(testValues);
	    Method m = t.getClass().getMethod(methodName);
	    int actual = (Integer) m.invoke(t);
	    expect(target,actual,
		   "constructor and " + methodName + "() work for " + value);
	} catch(Exception e) {
	    expect(String.valueOf(target),e.toString(),
		   "constructor and/or " +  methodName + "() don't work");
	}
    }

    @Test
    public void test6()
    {
    String name = "Bad Value";
    String rating = "bad rating";
    String value = rating;
    String target = "none";
    String methodName = "getRating";
	try {
	    Object[] testValues = {name,rating};
	    Object t = getTestInstance(testValues);
	    Method m = t.getClass().getMethod(methodName);
	    int actual = (Integer) m.invoke(t);
	    expect(target,actual,
		   "constructor and " + methodName + "() work for " + value);
	} catch(Exception e) {
	    expect(String.valueOf(target),e.toString(),
		   "constructor and/or " +  methodName + "() don't work");
	}
	}
@Test
    public void test7()
    {
    String name = "No Rating";
    String rating = "none";
    String value = rating;
    String target = value;
    String methodName = "getRating";
	try {
	    Object[] testValues = {name,rating};
	    Object t = getTestInstance(testValues);
	    Method m = t.getClass().getMethod(methodName);
	    int actual = (Integer) m.invoke(t);
	    expect(target,actual,
		   "constructor and " + methodName + "() work for " + value);
	} catch(Exception e) {
	    expect(String.valueOf(target),e.toString(),
		   "constructor and/or " +  methodName + "() don't work");
	}
    }


   
   
}

          ]]>
	</tests>

      </program>

  </exercise>
  <exercise label="jmex_code_challenge_copy_monitor">
    <statement>
      <p>
	<em>Challenge.</em>
	Define a <c>CopyMonitor</c> class that solves the following problem.
	A company needs a monitor program to keep track of when a particular copy machine needs service.
	The device has two important (boolean) variables:
	its toner level(too low or not)and whether it has printed more than 100,000 pages 
	since its last servicing (it either has or has not).  The servicing rule that the 
	company uses is that service is needed when either 100,000 pages have been printed 
	or the toner is too low.  Your program should contain a method that reports either
	<q>service needed</q> or <q>service not needed</q> based on the machine's state.
	(Pretend that the machine has other methods that keep track of toner level and page count.)
	Write a complete Java application program.
      </p>
    </statement>
    <response />
  </exercise>
  <exercise label="jmex_code_challenge_old_macdonald">
    <statement>
      <p>
	<em>Challenge.</em>
	Design and write an <c>OldMacdonald</c> class that sings several verses of
	<q>Old MacDonald Had a Farm.</q>
	Use methods to generalize the verses.  For example, write a method named <c>eieio()</c> to
	<q>sing</q> the <q><em>E I E I O</em></q> part of the verse.
	Write another method with the signature <c>hadAnX(String s)</c>, which sings the
	<q>had a duck</q> part of the verse,
	and a method <c>withA(String sound)</c> to sing the
	<q>with a quack quack here</q> part of the verse.
	Test your class by writing a <c>main()</c> method.
	Write a complete Java application program.
      </p>
    </statement>
    <response />
  </exercise>
  <exercise label="jmex_draw_uml_a_b_inheritence" attachment="yes">
    <statement>
      <p>
	Suppose you have an <c>Object A</c>, with public methods
	<c>a()</c>, <c>b()</c>, and private method <c>c()</c>. And suppose you have a subclass of <c>A</c> 
	named <c>B</c> with methods named
	<c>b()</c>, <c>c()</c> and <c>d()</c>. Draw a UML diagram showing the relationship between these 
	two classes. Explain the inheritance relationships between them and identify those methods that 
	would be considered polymorphic.
      </p>
    </statement>
    <response />
  </exercise>
  <exercise label="jmex_code_inherit_b_from_c">
    <statement>
      <p>
	Consider the definition of the class <c>C</c>. Define a subclass of <c>C</c> named <c>B</c> that overrides method <c>m1()</c> so that it returns the difference between <c>m</c> and <c>n</c> instead of their sum.
	<program language="java"><input>
	  public class C {
	  private int m;
	  private int n;
	  public C(int mIn, int nIn) {
	  m = mIn;
	  n = nIn;
	  }
	  public int m1() {
	  return m+n;
	  }
	  }
	</input></program>
      </p>
    </statement>
    <response />
  </exercise>
  
</subsection>
</section> 
