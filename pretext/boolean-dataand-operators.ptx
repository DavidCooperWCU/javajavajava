<section xml:id="boolean-dataand-operators">
  <title>Boolean Data and Operators</title>
  <introduction>
    <p>
      As we learned in Chapter<nbsp/>
1,
      the <c>boolean</c> type is one of Java's primitive types.
      For this type,
      there are only two possible values, <c>true</c> and <c>false</c>. The <c>boolean</c> type is derived from the work of British mathematician George Boole,
    <idx>
      <h>Boole, George</h>
    </idx>
      \marginpar{George Boole} who in the 1850s,
      developed an algebra to process logical expressions such as <em>p and q</em>.
      Such <em>boolean expressions</em>
      produce a value that is either <em>true</em> or <em>false</em>.
      Every modern programming language provides some means of representing boolean expressions.
  </p>
  <p>
      The <c>boolean</c> type has several important uses.
      As we saw in Chapter<nbsp/>
1,
      expressions of the form <c>num == 7</c> and
  <c>5 &lt; 7</c> have <c>boolean</c> values.
      Similarly, as we saw in Chapter<nbsp/>
3, \marginpar{Conditional statement} the <c>boolean</c> type is also used to represent the condition in the if statement:
<md>
        \matrix{ \hbox{if} \amp  ( \hbox{boolean expression} )\cr \amp  \hbox{statement} ;\cr}
</md>
</p>
<p>
      For this reason,
      boolean expressions are also called <em>conditions</em>.
      Along these same lines,
      a <c>boolean</c> variable can be used as a
<em>flag</em> or a <em>signal</em> to
<q>remember</q>
      \marginpar{Boolean flag} whether or not a certain condition holds.
      For example, in the following code fragment,
      we use <c>isDone</c> to mark when a particular process is completed:
</p>
<pre>
boolean isDone = false; // Initialize the flag
...                     // Do some processing task
isDone = true;          // Set flag when the task done
...                     // Do some other stuff
if (isDone)             // Check if finished the task
...                     //  If so, do something
else
...                     //  Or, do something else
</pre>
</introduction>
<subsection xml:id="self-study-exercisesA16">
<title>Boolean (or Logical) Operations</title>
<p>
      Like all the other simple data types,
      the <c>boolean</c> type consists \marginpar{Data and operations} of certain data<mdash/>
the values <c>true</c> and <c>false</c>
<mdash/>
and certain actions or operations that can be performed on those data.
      For the boolean type there are four basic operations: AND
      (signified by &amp;&amp;),
      OR
      (signified by <m>\mid\mid</m>),
      EXCLUSIVE-OR
      (signified by <m>\wedge</m>),
      and NOT
      (signified by !).
      These are defined in the <em>truth table</em>
      shown in Table<nbsp/>
5.1.
      A truth tables defines boolean operators by giving their values in all possible situations.
      The first two columns of the table give possible boolean values for two
<em>operands</em>,<c>o1</c> and <c>o2</c>. An <term>operand</term>
      is a value used in an operation.
      Note that each row gives a different value assignment to the two operands,
      so that all possible assignments are represented.
      The remaining columns give the values that result for the various operators given the assignment of values to <c>o1</c> and <c>o2</c>.
</p>
<table>
      \TBT{3.0pc}{Truth-table definitions of the boolean operators:
      AND (&amp;&amp;), OR (<m>\mid\mid</m>), EXCLUSIVE-OR (<m>\wedge</m>), and  NOT (!)}
      
<tabular>
<row>
<cell>\multicolumn{6}{l}{\rule{21pc}{1pt}}</cell>
</row>
<row>
<cell>{o1}</cell>
<cell>{o2}</cell>
<cell>{o1 \</cell>
<cell>\</cell>
<cell>o2}</cell>
<cell>{o1 <m>\mid\mid</m> o2}</cell>
<cell>{o1 <m>\wedge</m> o2}</cell>
<cell>{!o1}</cell>
</row>
<row>
<cell>[-4pt]\multicolumn{6}{l}{\rule{21pc}{0.5pt}}</cell>
</row>
<row>
<cell>
  <c>true</c>
</cell>
<cell>
  <c>true</c>
</cell>
<cell>
  <c>true</c>
</cell>
<cell>
  <c>true</c>
</cell>
<cell>
  <c>false</c>
</cell>
<cell>
  <c>false</c>\cr
  <c>true</c>
</cell>
<cell>
  <c>false</c>
</cell>
<cell>
  <c>false</c>
</cell>
<cell>
  <c>true</c>
</cell>
<cell>
  <c>true</c>
</cell>
<cell>
  <c>false</c>\cr
  <c>false</c>
</cell>
<cell>
  <c>true</c>
</cell>
<cell>
  <c>false</c>
</cell>
<cell>
  <c>true</c>
</cell>
<cell>
  <c>true</c>
</cell>
<cell>
  <c>true</c>\cr
  <c>false</c>
</cell>
<cell>
  <c>false</c>
</cell>
<cell>
  <c>false</c>
</cell>
<cell>
  <c>false</c>
</cell>
<cell>
  <c>false</c>
</cell>
<cell>
  <c>true</c>
</cell>
</row>
<row>
<cell>[-4pt]\multicolumn{6}{l}{\rule{21pc}{1pt}}</cell>
</row>
</tabular>
      \endTB
</table>
<p>
      To see how to read this table,
      let's look at the AND operation,
      which is defined in column 3.
      The AND operator is a <term>binary operator</term>
<mdash/>
that is,
      it requires two operands, \marginpar{Binary operator}<em>o1</em> and <em>o2</em>.
      If both <em>o1</em> and <em>o2</em> are true,
      then (<em>o1</em> &amp;&amp; <em>o2</em>) is true
      (row1).
      If either <em>o1</em> or <em>o2</em> or both <em>o1</em>
      and <em>o2</em> are false,
      then the expression (<em>o1</em> &amp;&amp;
<em>o2</em>) is false
      (rows 2 and 3).
      The only case in which (<em>o1</em> &amp;&amp;
<em>o2</em>) is true is when both
<em>o1</em> and <em>o2</em> are true
      (row 4).
</p>
<p>
      The boolean OR operation (column 4 of Table<nbsp/>
5.1) is also a binary operation.
      If both <em>o1</em> and <em>o2</em> are false,
      then <m>(o1 \mid\mid o2)</m> is false
      (row 4).
      If either <em>o1</em> or <em>o2</em> or both <em>o1</em>
      and <em>o2</em> are true,
      then the expression <m>(o1 \mid\mid o2)</m> is true
      (rows 1-3).
      Thus, the only case in which
<m>(o1 \mid\mid o2)</m> is false is when both <em>o1</em>
      and <em>o2</em> are false.
</p>
<p>
      The boolean EXCLUSIVE-OR operation (column 5 of Table<nbsp/>
5.1) is a binary operation,
      which differs from the OR operator in that it is true when either <em>o1</em>
      or <em>o2</em> is true (rows 2 and 3),
      but it is false when both <em>o1</em> and <em>o2</em> are true
      (row 1).
</p>
<p>
      The NOT operation
      (the last column of Table<nbsp/>
5.1)
      is a \marginpar{Unary operator}<term>unary operator</term>
<mdash/>
it takes only one operand<mdash/>
and it simply reverses the truth value of its operand.
      Thus, if <em>o1</em> is true, !<em>o1</em>
      is false, and vice versa.
</p>
</subsection>
<subsection>
<title>Precedence and Associativity</title>
<p>
      In order to evaluate complex boolean expressions,
      it is necessary to understand the order in which boolean operations are carried out by the computer.
      For example, what is the value of the following expression?
</p>
<pre>
true || true AmPaMp false
</pre>
<p>
      The value of this expression depends on whether we evaluate the
<m>\mid\mid</m> first or the &amp;&amp; first.
      If we evaluate the <m>\mid\mid</m> first,
      the expression's value will be false;
      if we evaluate the &amp;&amp;
      first, the expression's value will be true.
      In the following example,
      we use parentheses to force one operation to be done before the other:
</p>
<pre>
EXPRESSION                EVALUATION
----------                ----------
( true || true ) AmPaMp false ==> true AmPaMp false ==> false
true || ( true AmPaMp false ) ==> true || false ==> true
</pre>
<p>
      As these evaluations show,
      we can use parentheses to force one operator or the other to be evaluated first.
      However, in \marginpar{Parentheses supersede} Java,
      the &amp;&amp; \mbox{operator} has higher precedence
<idx>
<h>precedence</h>
</idx>
      than the <m>\mid\mid</m> operator.
      Therefore, the second alternative corresponds to the default interpretation that Java would apply to the expression that has no parentheses.
      In other words,
      given the expression <m>true \; \mid\mid \; true \; \\amp \\amp \; false</m>,
      the AND operation would be evaluated before the OR operation even though the OR operator occurs first (i.e., to the left) in the unparenthesized expression.
</p>
<table>
      \TBT{4pc}{Precedence order of the boolean operators}
      
<tabular>
<row>
<cell>\multicolumn{3}{l}{\rule{19pc}{1pt}}</cell>
</row>
<row>
<cell>{Precedence Order}</cell>
<cell>{Operator}</cell>
<cell>{Operation}</cell>
</row>
<row>
<cell>[-4pt]\multicolumn{3}{l}{\rule{19pc}{0.5pt}}</cell>
</row>
<row>
<cell>1</cell>
<cell>
<c>(  )</c>
</cell>
<cell>Parentheses</cell>
</row>
<row>
<cell>2</cell>
<cell>
<c>!</c>
</cell>
<cell>NOT</cell>
</row>
<row>
<cell>3</cell>
<cell>
<c> \wedge </c>
</cell>
<cell>EXCLUSIVE-OR</cell>
</row>
<row>
<cell>4</cell>
<cell>
<c>&amp;&amp;</c>
</cell>
<cell>AND</cell>
</row>
<row>
<cell>5</cell>
<cell>
<c>||</c>
</cell>
<cell>OR</cell>
</row>
<row>
<cell>[-4pt]\multicolumn{3}{l}{\rule{19pc}{1pt}}</cell>
</row>
</tabular>
      \endTB
</table>
<p>
      As this example illustrates,
      the boolean operators have a built-in
<term>precedence order</term>
      which is used to determine how boolean expressions are to be evaluated (Table<nbsp/>
5.2).
      A simple method for evaluating an expression is to parenthesize the expression and then evaluate it.
      For example, to evaluate the complex expression
</p>
<pre>
true || !false ^ false AmPaMp true
</pre>
<p>
      we would first parenthesize it according to the precedence rules set out in Table<nbsp/>
5.2, which gives the following expression:
</p>
<pre>
true || (((!false) ^ false) AmPaMp true)
</pre>
<p>
      We can then evaluate this fully parenthesized expression,
      step by step, starting at the innermost parentheses:
</p>
<pre>
Step 1. true || ((true ^ false) AmPaMp true)
Step 2. true || (true AmPaMp true)
Step 3. true || true
Step 4. true
</pre>
<principle>
<title>PROGRAMMING TIP:Parentheses</title>
<p>
        Parentheses can
        (and should)
        be used to clarify any expression that appears ambiguous or to override Java's default precedence rules.
</p>
</principle>
<p>
      In addition to operator precedence,
      it is necessary to know about an operator's <em>associativity</em>
      in order to evaluate boolean expressions of the form <m>\texttt{(op1 \mid\mid op2 \mid\mid op3)}</m>.
      Should this expression be evaluated as
<m>\texttt{((op1 \mid\mid op2) \mid\mid op3)}</m> or as <m>\texttt{(op1 \mid\mid (op2 \mid\mid op3))}</m>?
      The binary boolean operators all associate from left to right.
      Thus, the expressions
</p>
<pre>
true ^ true ^ true   // Same as: (true ^ true) ^ true
true AmPaMp true AmPaMp true // Same as: (true AmPaMp true) AmPaMp true
true || true || true // Same as: (true || true) || true
</pre>
<p>
      would be evaluated as follows:
</p>
<pre>
EXPRESSION               EVALUATION
----------------         -----------------
(true ^ true)  ^ true    ==> false ^ true  ==> true
(true AmPaMp true)  AmPaMp true  ==> true  AmPaMp true ==> true
(true || true)  || true  ==> true  || true ==> true
</pre>
</subsection>
<subsection xml:id="self-study-exerciseN16">
<title>Short-Circuit Evaluation</title>
<p>
      Another important feature of the boolean operators is that they utilize a form of evaluation known as
<em>short-circuit evaluation</em>.
      In <term>short-circuit evaluation</term>,
      a boolean expression is evaluated from left to right,
      and the evaluation is discontinued as soon as the expression's value can be determined,
      regardless of whether it contains additional operators and operands.
      For example, in the expression
</p>
<pre>
expr1 AmPaMp expr2
</pre>
<p>
      if <c>expr1</c> is false,
      then the AND expression must be false,
      so <c>expr2</c> need not evaluated.
      Similarly, in the expression
</p>
<pre>
expr1 || expr2
</pre>
<p>
      if <c>expr1</c> is true,
      then the OR expression must be true,
      so
<c>expr2</c> need not evaluated.
</p>
<p>
      In addition to being a more efficient form of evaluating boolean expressions,
      short-circuit evaluation has some practical uses.
      For example,
      we can use short-circuit evaluation to guard against null pointer exceptions.
      Recall from Chapter<nbsp/>
2 that a null pointer exception results when you try to use an uninstantiated reference variable<mdash/>
that is,
      a reference variable that has not been assigned an object.
      For example,
      if we declare a <c>OneRowNim</c> variable without instantiating it and then try to use it,
      a null pointer exception will result:
</p>
<pre>
OneRowNim game;        // Uninstantiated Reference
if (!game.gameOver())  // Null pointer exception
    game.takeSticks(num);
</pre>
<p>
      In this code,
      a null pointer exception results when we use <c>game</c> in the method call <c>game.gameOver()</c>. We can use short-circuit evaluation to prevent the exception from occurring:
</p>
<pre>
if ((game != null) AmPaMp (!game.gameOver())
    game.takeSticks(num);
</pre>
<p>
      In this case,
      because <c>game != null</c> is false,
      neither method call involving <c>game</c> is made,
      thus avoiding the exception.
</p>
</subsection>
</section>