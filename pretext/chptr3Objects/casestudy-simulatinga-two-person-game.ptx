<section xml:id="casestudy-simulatinga-two-person-game">
  <title>CASE STUDY: Simulating a Two-Person Game</title>
  <introduction>
    <p>
      In this section,
      we will design a class definition that keeps track of the details of a well known,
      two-person game.  Our objective is to understand what the program is doing and 
      how it works without necessarily understanding why it works the way it does.
      We will get to <q>why</q> later in the book.
    </p>
    <p>
      The game we will consider is played by two persons with a row of sticks or coins or other objects.
      The players alternate turns.
      A player must remove one,
      two, or three sticks from the row on his or her turn.
      The player who removes the last stick from the row loses.
      The game can be played with any number of sticks but starting with twenty one sticks is quite common.
      This game is sometimes referred to as the game of "Nim", but there is a similar 
      game involving multiple rows of sticks that is more frequently given that name.
      Thus we will refer to this game as "One Row Nim".
    </p>
  </introduction>
  <subsection>
    <title>Designing a OneRowNim class</title>
      <project>
      <term>Specification:</term> Design a class named <c>OneRowNim</c> that simulates the game of One Row Nim with a row of sticks.
        A <c>OneRowNim</c> object should manage data that corresponds to having some specified number 
        of sticks when the game begins. 
        It should keep track of whose turn it is and allow players to <q>take away</q> one, two,
        or three sticks.
        Finally, a <c>OneRowNim</c> object should be able to decide when the game is over and which player has won.
      </project>


    <subsubsection>
      <title>Problem Decomposition</title>
      <p>
        Let's design <c>OneRowNim</c> so that it can be used in with different kinds of user interfaces:
        <ul>
        <li><p>Person vs. persomn.</p></li>
        <li><p>Person vs. computer.</p></li>
        <li><p>Keyboard and console interface.</p></li>
        <li><p>Graphical interface.</p></li>
        </ul>
      </p>
      <p>
        In this chapter, we will work on the <c>OneRowNim</c> class.
        We will design the user interfaces in a subsequent chapter.
      </p>
    </subsubsection>
    <subsubsection>
      <title>Class Design: <c>OneRowNim</c></title>
      <p>
        As we saw in the <c>Riddle</c> example,
        class definitions are broken down into two parts: 
        <ol>
          <li><p>The information or attributes that the object needs (<term>variables</term>).</p></li>
          <li><p>The behavior or actions the object can take (<term>methods</term>).</p></li>
        </ol> 
      </p>
      <p>
        The <c>OneRowNim</c> object should manage two pieces of information  that vary as the game is played.
        One is the number of sticks remaining in the row and the other is which player has the next turn. We can 
        represent both of these as whole numbers, which correspond to <c>int</c> in Java:
        <tabular>
          <row><cell>Variable Name</cell> <cell>Type</cell> <cell> Values</cell></row>
          <row><cell>-------------</cell> <cell> <c>----</c></cell> <cell>------</cell></row>
          <row><cell>nSticks</cell> <cell> <c> int</c></cell> <cell> 0 through 21</cell></row>
          <row><cell>player</cell> <cell> <c> int</c></cell> <cell> 1 or 2</cell></row>
        </tabular>          
      </p>
      <p>
        As this table suggests, we will represent our two players as the numbers 1 or 2.
      </p>
      <p>
        During the playing of the game, the values of these two variables will represent the state of the game:
        whose turn it is, and whose turn it is.
      </p>
    </subsubsection>
    <subsubsection xml:id="fig-ornuml">
      <title>Method Decomposition</title>
      <p>
        Now that we have decided the variables for <c>OneRowNim</c>, we need to design its methods. One action needed
        is the taking away of 1-3 sticks. The easiest way to do this is to have three methods corresponding to taking one, two,
        or three sticks: <c>takeOne()</c>, <c>takeTwo()</c>, and <c>takeThree()</c>.  Each method will be responsible 
        for reducing the value of <c>nSticks</c> as well as switching to the other <c>player</c>.
      </p>
      <p>
        (Once we learn how to use parameters and return values (next chapter), we'll be able to replace these three 
        methods with a single method that can take away 1, 2 or 3 sticks.) 
      </p>
      <p>
        We also need a method that gives the information that a user needs when considering a move.  The <c>report()</c>
        method will report the number of sticks remaining and whose turn it is.
      </p>
      <p>
        <xref ref="fig-onerownimclass">Figure</xref> is a UML class diagram that summarizes our design decisions.
        Note that the instance variables are declared private (<m>-</m>) to hide them from other objects, and the methods 
        are declared public (<m>+</m>) and will thereby form the <c>OneRowNim</c> interface.
        These will be the methods that other objects will use to interact with it. 
      </p>
      <figure xml:id="fig-onerownimclass">
        <caption>The <c>OneRowNim</c> class.</caption>
        <image width="40%" source="chptr02/onerow3.png"/> 
      </figure>
    </subsubsection>
  </subsection>
  <subsection>
    <title>Defining the <c>OneRowNim</c>Class</title>
    <introduction>
      <p>
        Given our design of the <c>OneRowNim</c> class as described in Figure<nbsp/>2.16,
        the next step in building our simulation is to begin writing the Java class definition.
      </p>
    </introduction>
    <subsubsection xml:id="fig-pedigree">
      <title>The Class Header</title>
      <p>
        We need a <em>class header</em>,
        which will give the class a name and will specify its relationship to other classes.
        Like all classes that are designed to create objects that could be used by other objects or classes,
        the class <c>OneRowNim</c> should be preceded by the <c>public</c> modifier.
        Because the class <c>OneRowNim</c> has not been described as having any relationship to any other Java class,
        its header can omit the <c>extends</c> clause so it will be a direct subclass of <c>Object</c> 
        (<xref ref="fig-onerownim1">(Figure</xref>).
         Thus,
        the class header for <c>OneRowNim</c> will look like:
      </p>
      <figure xml:id="fig-onerownim1">
        <caption><c>OneRowNim</c> is a sub-class of <c>Object</c>.</caption>
      <image width="73%" source="chptr02/onerow1.png"/>
      </figure>
 <program language="java"><input>
public class OneRowNim  // Class header
{                       // Beginning of class body
}                       // End of class body
 </input></program>
    </subsubsection>
    <subsubsection>
      <title>The Class's Instance Variables</title>
      <p>
        The body of a class definition consists of  two parts:
        the class-level variables and the method definitions.
        A <term>class-level variable</term>
        is a variable whose definition applies to the entire class in which it is defined.
        Instance variables, which were introduced in Chapter<nbsp/>1,
        are one kind of class-level variable.
      </p>
      <p>
        In general, a class definition will take the form shown in <xref ref="fig-form">Figure</xref>.
      </p>
      <figure xml:id="fig-form">
        <caption>A template for constructing a Java class definition.</caption>
 <program language="java"><input>
public class ClassName
{  // Instance and class variables
     VariableDeclaration1
     VariableDeclaration2
     ...
    // Instance and class methods
     MethodDefinition1
     MethodDefinition2
     ...} // End of class
 </input></program>
      </figure>
      <p>
        Although Java does not impose any particular order on variable and method declarations,
        in this book we'll define the class's class-level variables at the beginning of the class definition,
        followed by method definitions.
        Class-level variables are distinguished from  local variables.
        A <term>local variable</term> is a variable that is defined within a method.
        Examples would be the variables <c>q</c> and <c>a</c> that were defined in the <c>Riddle(String q, String a)</c> constructor (Fig.
        <xref ref="fig-riddleclass2"></xref>).
        As we will see better in Chapter 3, Java handles each type of variable differently.
      </p>
      <p>
        A declaration for a variable at class level must follow the rules for declaring variables that were described in <xref ref="subsec_vardecl">Section</xref>
        with the added restriction that they should be modified by one of the access modifiers <c>public</c>, <c>private</c>, or <c>protected</c>. The rules associated with these access modifiers are:
        <ul>
          <li>
            <p>
              A <c>private</c> class-level variable cannot be accessed outside the class in which it is declared.
            </p>
          </li>
          <li>
            <p>
              A <c>public</c> class-level variable can be referenced and,
              hence, modified by any other class.
            </p>
          </li>
          <li>
            <p>
              A <c>protected</c> class-level variable can only be accessed by subclasses of the class in which it is declared or by other classes that belong to the same package.
            </p>
          </li>
        </ul>
      </p>
      <p>
        When a class, instance variable, or method is defined,
        you can declare it <c>public</c>, <c>protected</c>, or <c>private</c>. Or you can leave its access unspecified,
        in which case Java's default accessibility will apply.
      </p>
      <p>
        Java determines accessibility in a top-down manner.
        Instance variables and methods are contained in classes,
        which are contained in packages.
        To determine whether a instance variable or method is accessible, Java starts by determining whether its containing package is accessible,
        and then whether its containing class is accessible.
        Access to classes, instance variables,
        and methods is defined according to the rules shown in Table<nbsp/>2.2.
      </p>
      <table>
        \vspace{6pt}\TBT{0pc}{Java's accessibility rules.}
        
        <tabular>
          <row>
            <cell><c>__________</c></cell>
          </row>
          <row>
            <cell>{Element}</cell>
            <cell>{Modifier}</cell>
            <cell>{Rule}</cell>
          </row>
          <row>
            <cell><c>__________</c></cell>
          </row>
          <row>
            <cell>Class</cell>
            <cell><c>public</c></cell>
            <cell>Accessible if its package is accessible.</cell>
          </row>
          <row>
            <cell></cell>
            <cell>by default</cell>
            <cell>Accessible only within its package.</cell>
          </row>
          <row>
            <cell><c>__________</c></cell>
          </row>
          <row>
            <cell>Instance variable</cell>
            <cell><c>public</c></cell>
            <cell>Accessible to all other objects.</cell>
          </row>
          <row>
            <cell><nbsp/><nbsp/> or</cell>
            <cell><c>protected</c></cell>
            <cell>Accessible to its subclasses and to</cell>
          </row>
          <row>
            <cell><nbsp/><nbsp/> instance method</cell>
            <cell></cell>
            <cell><nbsp/><nbsp/>  other classes in its package.</cell>
          </row>
          <row>
            <cell></cell>
            <cell><c>private</c></cell>
            <cell>Accessible only within the class.</cell>
          </row>
          <row>
            <cell></cell>
            <cell>by default</cell>
            <cell>Accessible only within the package.</cell>
          </row>
          <row>
            <cell><c>__________</c></cell>
          </row>
        </tabular>
        \endTB
        \vspace{-6pt}
      </table>
      <p>
        Recall the distinction we made in Chapter 0 between class variables and instance variables.
        A class variable is associated with the class itself,
        whereas an instance variable is associated with each of the class's instances.
        In other words,
        each object contains its own copy of the class's instance variables,
        but only the class itself contains the single copy of a class variable.
        To designate a variable as a class variable it must be declared <c>static</c>.
      </p>
      <p>
        The <c>Riddle</c> class that we considered earlier has the following two examples of valid declarations of instance variables:
      </p>
 <program language="java"><input>
private String question;
private String answer;
 </input></program>
    </subsubsection>
    <subsubsection>
      <title>Class Level Variables for <c>OneRowNim</c></title>
      <p>
        Let's now consider how to declare the class level variables for the <c>OneRowNim</c> class.
        The UML class diagram for <c>OneRowNim</c> in Figure<nbsp/>2.16 contains all the information we need.
        The variables <c>nSticks</c> and <c>player</c> will store data for playing one game of One Row Nim,
        so they should clearly be private instance variables.
        They both will store integer values,
        so they should be declared as variables of type <c>int</c>. Because we wish to start a game of One Row Nim using 7 sticks with player one making the first move,
        we will assign 7 as the initial value for <c>nSticks</c> and 1 as the initial value for <c>player</c>. If we add the declarations for our instance variable declarations to the class header for the <c>OneRowNim</c> class,
        we get the following:
      </p>
 <program language="java"><input>
public class OneRowNim
{
  private int nSticks = 7;
  private int player = 1;
  //Method definitions go here} // OneRowNim
 </input></program>
      <p>
        To summarize, despite its apparent simplicity,
        a class level variable declaration actually accomplishes five tasks:
      </p>
      <p>
        \begin{NL} \item Sets aside a portion of the object's memory that can be used to store a certain type of data.
      </p>
      <p>
        \item Specifies the type of data that can be stored in that location.
      </p>
      <p>
        \item Associates an identifier
        (or name)
        with that location.
      </p>
      <p>
        \item Determines which objects have access to the variable's name.
      </p>
      <p>
        \item Assigns an initial value to the location. \end{NL}
      </p>
    </subsubsection>
    <subsubsection>
      <title><em>OneRowNim</em>'s Methods</title>
      <p>
        Designing and defining methods is a form of abstraction.
        By defining a certain sequence of actions as a method,
        you encapsulate those actions under a single name that can be invoked whenever needed.
        Instead of having to list the entire sequence again each time you want it performed,
        you simply call it by name.
        As you recall from Chapter 1, a method definition consists of two parts,
        the method header and the method body.
        The method header declares the name of the method and other general information about the method.
        The method body contains the executable statements that the method performs.
      </p>
 <program language="java"><input>
public void methodName()  // Method header
{                  // Beginning of method body}                  // End of method body
 </input></program>
    </subsubsection>
    <subsubsection>
      <title>The Method Header</title>
      <p>
        The method header follows a general format that consists of one or more
        <em>MethodModifiers</em>,
        the method's <em>ResultType</em>, the <em>MethodName</em>,
        and the method's <em>FormalParameterList</em>,
        which is enclosed in parentheses.
        The following table illustrates the method header form,
        and includes several examples of method headers that we have already encountered.
        The method body follows the method header.
      </p>
      <table>
        
        <tabular>
          <row>
            <cell><c>__________</c></cell>
          </row>
          <row>
            <cell>{MethodModifiers}<m>_{opt}</m></cell>
            <cell>{ResultType}</cell>
            <cell>{MethodName}</cell>
            <cell>{(FormalParameterList)}</cell>
          </row>
          <row>
            <cell><c>__________</c></cell>
          </row>
          <row>
            <cell><c>public</c><c>static</c></cell>
            <cell><c>void</c></cell>
            <cell><c>main</c></cell>
            <cell><c>
(String argv[])</c>\cr
    <c>public</c></cell>
            <cell><c>void</c></cell>
            <cell><c>paint</c></cell>
            <cell><c>(Graphics g)</c>\cr
    <c>public</c></cell>
            <cell></cell>
            <cell><c>Riddle</c></cell>
            <cell><c>(String q, String a)</c>\cr
    <c>public</c></cell>
            <cell><c>String</c></cell>
            <cell><c>getQuestion</c></cell>
            <cell><c>()</c>\cr
    <c>public</c></cell>
            <cell><c>String</c></cell>
            <cell><c>getAnswer</c></cell>
            <cell><c>()</c>\cr</cell>
          </row>
          <row>
            <cell><c>__________</c>
              \endUNTB</cell>
          </row>
        </tabular>
      </table>
      <p>
        The rules on method access are the same as the rules on instance variable access: <c>private</c> methods are accessible only within the class itself, <c>protected</c> methods are accessible only to subclasses of the class in which the method is defined and to other classes in the same package,
        and <c>public</c> methods are accessible to all other classes.
      </p>
      <principle>
        <title>EFFECTIVE DESIGN:Public versus Private Methods</title>
        <p>
          If a method is used to communicate with an object,
          or if it passes information to or from an object,
          it should be declared <c>public</c>. If a method is intended to be used solely for internal operations within the object,
          it should be declared <c>private</c>. These methods are sometimes called
          <term>utility methods</term>
          or <term>helper methods</term>.
        </p>
      </principle>
      <p>
        Recall the distinction from Chapter 0 between instance methods and class methods.
        Methods declared at the class level are assumed to be instance methods unless they are also declared <c>static</c>. The
        <em>static modifier</em>
        is used to declare that a class method or variable is associated with the class itself,
        rather than with its instances.
        Just as for <c>static</c> variables,
        methods that are declared <c>static</c> are associated with the class and are therefore called <em>class methods</em>.
        As its name implies,
        an instance method can only be used in association with an object
        (or instance)
        of a class.
        Most of the class-level methods we declare will be instance methods.
        Class methods are used only rarely in Java and mainly in situations where it is necessary to perform some kind calculation before objects of the class are created.
        We will see examples of class methods when we discuss the <c>Math</c> class,
        which has such methods as <c>sqrt(N)</c> to calculate the square root of <em>N</em>.
      </p>
      <principle>
        <title>PROGRAMMING TIP:Class versus Instance Methods</title>
        <p>
          If a method is designed to be used by an object,
          it is referred to as an instance method.
          No modifier is needed to designate an instance method.
          Class methods,
          which are used infrequently compared to instance methods,
          must be declared <c>static</c>.
        </p>
      </principle>
      <p>
        All four of the methods in the <c>OneRowNim</c> class are instance methods (Fig.<nbsp/>2.19).
        They all perform actions
      </p>
      <figure xml:id="fig-ornmheaders">
        <caption>The Instance variables and method headers for the <c>
OneRowNim</c> class.</caption>
 <program language="java"><input>
public class OneRowNim
{ private int nSticks = 7; // Start with 7 sticks.
  private int player = 1;  // Player 1 plays first.
  public void takeOne(){ } // Method bodies need
  public void takeTwo(){ } //  to be defined.
  public void takeThree(){ }
  public void report(){ }} //OneRowNim class
 </input></program>
      </figure>
      <p>
        associated with a particular instance of <c>OneRowNim</c>. That is,
        they are all used to manage a particular One Row Nim game.
        Moreover, all four methods should be declared <c>public</c>, because they are designed for communicating with other objects rather than for performing internal calculations.
        Three of the methods are described as changing the values of the instance variables <c>nSticks</c> and
<c>player</c> and the fourth, <c>report()</c>, writes information to the console.
        All four methods will receive no data when being called and will not return any values.
        Thus they should all have <c>void</c> as a return type and should all have empty parameter lists.
      </p>
      <p>
        Given these design decisions,
        we now can add method headers to our class definition of <c>OneRowNim</c>, in <xref ref="fig-ornmheaders">Figure</xref>.
        The figure displays the class header,
        instance variable declarations, and method headers.
      </p>
    </subsubsection>
    <subsubsection>
      <title>The Method Body</title>
      <p>
        The body of a method definition is a block of Java  statements enclosed by braces, , which are executed in sequence when the method is called.
        The description of the action required of the <c>takeOne()</c> method is typical of many methods that change the state of an object.
        The body of the <c>takeOne()</c> method should use a series of assignment statements to reduce the value stored in <c>nSticks</c> by one and change the value in <c>player</c> from 2 to 1 or from 1 to 2.
        The first change is accomplished in a straightforward way by the assignment:
      </p>
 <program language="java"><input>
nSticks = nSticks - 1;
 </input></program>
      <p>
        This statement says subtract 1 from the value stored in <c>nSticks</c> and assign the new value back to <c>nSticks</c>.
      </p>
      <p>
        Deciding how to change the value in <c>player</c> is more difficult because we do not know whether its current value is 1 or 2.
        If its current value is 1, its new value should be 2;
        if its current value is 2, its new value should be 1.
        Notice, however,
        that in both cases the current value plus the desired new value are equal to 3.
        Therefore, the new value of <c>player</c> is equal to 3 minus its current value.
        Writing this as an assignment we have:
      </p>
 <program language="java"><input>
player = 3 - player;
 </input></program>
      <p>
        One can easily verify that this clever assignment assigns 2 to <c>player</c> if its current value is 1 and assigns 1 to it if its current value is 2.
        In effect, this assignment will toggle the value off <c>player</c> between 1 and 2 each time it is executed.
        In the next chapter we will introduce the <c>if-else</c> control structure that would allow us to accomplish this same toggling action in a more straightforward manner.
        The complete definition of <c>takeOne()</c> method becomes:
      </p>
 <program language="java"><input>
public void takeOne()
{
   nSticks = nSticks - 1;  // Take one stick
   player = 3 - player;    // Change to other player}
 </input></program>
      <p>
        The <c>takeTwo()</c> and <c>takeThree()</c> methods are completely analogous to the <c>takeOne()</c> method with the only difference being the amount subtracted from <c>nSticks</c>.
      </p>
      <p>
        The body of the <c>report()</c> method must merely print the current values of the instance variables to the console window with <c>System.out.println()</c>. To be understandable to someone using a <c>OneRowNim</c> object,
        the values should be clearly labeled.
        Thus the body of <c>report()</c> could contain:
      </p>
 <program language="java"><input>
System.out.println("Number of sticks left: " + nSticks);
System.out.println("Next turn by player " + player);
 </input></program>
      <p>
        This completes the method bodies of the <c>OneRowNim</c> class.
        The completed class definition is shown in <xref ref="fig-orndef">Figure</xref>.
      </p>
      <figure xml:id="fig-orndef">
        <caption>The <c>OneRowNim</c> class definition.</caption>
        
 <program language="java"><input>
public class OneRowNim
{ private int nSticks = 7; // Start with 7 sticks.
  private int player = 1;  //Player 1 plays first.
  public void takeOne()
  { nSticks = nSticks - 1;
    player = 3 - player;
  } // takeOne()
  public void takeTwo()
  { nSticks = nSticks - 2;
    player = 3 - player;
  } // takeTwo()
  public void takeThree()
  { nSticks = nSticks - 3;
    player = 3 - player;
  }  // takeThree()
  public void report()
  { System.out.println("Number of sticks left: " + nSticks);
    System.out.println("Next turn by player " + player);
  }   // report()} // OneRowNim1 class
 </input></program>
      </figure>
      <p>
        We will discuss alternative methods for this class in the next chapter.
        In Chapter 4, we will develop several One Row Nim user interface classes that will facilitate a user indicating certain moves to make.
      </p>
    </subsubsection>
  </subsection>
  <subsection xml:id="self-study-exercisesC10">
    <title>Testing the <c>OneRowNim</c>Class</title>
    <p>
      Recall our <em>define, create,
      and use</em> mantra from <xref ref="sect-mantra">Section</xref>.
      Now that we have defined the <c>OneRowNim</c> class,
      we can test whether it works correctly by creating
<c>OneRowNim</c> objects and using them to perform the actions associated with the game.
      At this point,
      we can test <c>OneRowNim</c> by defining a <c>main()</c> method.
      Following the design we used in the riddle example,
      we will locate the <c>main()</c> method in separate,
      user interface class,
      named <c>OneRowNimTester</c>.
    </p>
    <p>
      The body of <c>main()</c> should declare a variable of type <c>OneRowNim</c> and create an object for it to refer to.
      The variable can have any name,
      but a name like <c>game</c> would be consistent with it recording moves in a single game.
      To test the <c>OneRowNim</c> class,
      we should make a typical series of moves.
      For example,
      three moves taking 3, 3, and 1 sticks respectively would be one way that the 7 sticks could be removed.
      Also, executing the <c>report()</c> method before the first move and after each move should display the current state of the game in the console window so that we can determine whether it is working correctly.
    </p>
    <p>
      The following pseudocode outlines an appropriate sequence of statements in a <c>main()</c> method:
    </p>
    <sidebyside>
      \begin{NL}
      \item  Declare a variable of type <c>OneRowNim</c> named <c>game</c>.
      \item  Instantiate a <c>OneRowNim</c> object to which <c>game</c> refers.
      \item  Command <c>game</c> to report.
      \item  Command <c>game</c> to remove three sticks.
      \item  Command <c>game</c> to report.
      \item  Command <c>game</c> to remove three sticks.
      \item  Command <c>game</c> to report.
      \item  Command <c>game</c> to remove one stick.
      \item  Command <c>game</c> to report.
      \end{NL}
    </sidebyside>
    <p>
      It is now an easy task to convert the steps in the pseudocode outline into Java statements.
      The resulting <c>main()</c> method is shown with the complete definition of the <c>OneRowNimTester</c> class:
    </p>
 <program language="java"><input>
public class OneRowNimTester
{ public static void main(String args[])
  {   OneRowNim1 game = new OneRowNim();
      game.report();
      game.takeThree();
      game.report();
      game.takeThree();
      game.report();
      game.takeOne();
      game.report();
  } //main()}
 </input></program>
    <p>
      When it is run, <c>OneRowNimTester</c> produces the following output:
    </p>
 <program language="java"><input>
Number of sticks left: 7
    Next turn by player 1
    Number of sticks left: 4
    Next turn by player 2
    Number of sticks left: 1
    Next turn by player 1
    Number of sticks left: 0
    Next turn by player 2
 </input></program>
    <p>
      This output indicates that player 1 removed the final stick and so player 2 is the winner of this game.
    </p>

      </subsection><subsection><title>Self-Study Exercises</title>
      <p>
      <ol>
        <li>
          <p>
            Add a new declaration to the <c>Riddle</c> class for a <c>private String</c> instance variable named <c>hint</c>. Assign the variable an initial value of <c>"This riddle is too easy for a hint"</c>.
          </p>
        </li>
        <li>
          <p>
            Write a header for a new method definition for <c>Riddle</c> named <c>getHint()</c>. Assume that this method requires no parameters and that it simply returns the <c>String</c> value stored in the <c>hint</c> instance variable.
            Should this method be declared <c>public</c> or <c>private</c>?
          </p>
        </li>
        <li>
          <p>
            Write a header for the definition of a new <c>public</c> method for
<c>Riddle</c> named <c>setHint()</c> which sets the value of the <c>hint</c> instance variable to whatever <c>String</c> value it receives as a parameter.
            What should the result type be for this method?
          </p>
        </li>
        <li>
          <p>
            Create a partial definition of a <c>Student</c> class.
            Create instance variables for the first name,
            last name, and an integer student identification number.
            Write the headers for three methods.
            One method uses three parameters to set values for the three instance variables.
            One method returns the student identification number.
            The last method returns a <c>String</c> containing the student's first name and last name.
            Write only the headers for these methods.
          </p>
        </li>
      </ol>
    </p>
  </subsection>
  <subsection xml:id="sec-methodcall">
    <title>Flow of Control: Method Call and Return</title>
    <p>
      A program's <term>flow of control</term>
      is the order in which its statements are executed.
      In an object-oriented program,
      control passes from one object to another during the program's execution.
      It's important to have a clear understanding of this process.
    </p>
    <p>
      In order to understand a Java program,
      it is necessary to understand the
      <term>method call and return</term> mechanism.
      We will encounter it repeatedly.
      A method call causes a program to transfer control to a statement located in another method.
      <xref ref="fig-methodcall">Figure</xref>
      shows the method call and return structure.
    </p>
    <figure xml:id="fig-methodcall">
      <caption>The method call and return control structure.
      It's important to realize that <c>method1()</c> and <c>method2()</c> may
      be contained in different classes.</caption>
      <image width="73%" source="chptr02/2f16.png"/>
    </figure>
    <p>
      In this example, we have two methods.
      We make no assumptions about where these methods are in relation to each other.
      They could be defined in the same class or in different classes.
      The <c>method1()</c> method executes sequentially until it calls <c>method2()</c>. This transfers control to the first statement in <c>method2()</c>. Execution continues sequentially through the statements in <c>method2()</c> until the <c>return</c> statement is executed.
    </p>
    <principle>
      <title>Return Statement</title>
      <p>
        The <c>return</c> statement causes a method to return control to the
        <term>calling statement</term><mdash/>that is,
        to the statement that called the method in the first place.
      </p>
    </principle>
    <p>
      Recall that if a <c>void</c>
          <idx><h>void</h></idx>
      method does not contain a <c>return</c> statement,
      then control will  automatically return to the calling statement after the invoked method executes its last statement.
    </p>
  </subsection>
  <subsection xml:id="subsect-trace">
    <title>Tracing the <c>OneRowNim</c>Program</title>
    <p>
      To help us understand the flow of control in <c>OneRowNim</c>, we will perform a trace of its execution.
      <xref ref="fig-trace">Figure</xref>
      shows all of the Java code involved in the program.
      In order to simplify our trace,
      we have moved the <c>main()</c> method from <c>OneRowNimTester</c> to the <c>OneRowNim</c> class.
      This does not affect the program's order of execution in any way.
      But keep in mind that the code in the <c>main()</c> method could just as well appear
    </p>
    <figure xml:id="fig-trace">
      <caption>A trace of the <c>OneRowNim</c> program.</caption>
 <program language="java"><input>
public class OneRowNim
2 {  private int nSticks = 7; // Start with 7 sticks.
3    private int player = 1;  //Player 1 plays first.
      public void takeOne()
20    {  nSticks = nSticks - 1;
21       player = 3 - player;
      } // takeOne()
      public void takeTwo()
      {  nSticks = nSticks - 2;
         player = 3 - player;
      } // takeTwo()
      public void takeThree()
8,14  {  nSticks = nSticks - 3;
9,15     player = 3 - player;
      }  // takeThree()
      public void report()
5,11,17,23 { System.out.println("Number of sticks left: " + nSticks);
6,12,18,24   System.out.println("Next turn by player " + player);
      }   // report()
      public static void main(String args[])
1     {  OneRowNim1 game = new OneRowNim1();
4        game.report();
7        game.takeThree();
10       game.report();
13       game.takeThree();
16       game.report();
19       game.takeOne();
22       game.report();
23     } //main()
   } //OneRowNim1 class
 </input></program>
    </figure>
    <p>
      in the <c>OneRowNimTester</c> class.
      The listing in <xref ref="fig-trace">Figure</xref>
      also adds line numbers to the program to show the order in which its statements are executed.
    </p>
    <p>
      Execution of the <c>OneRowNim</c> program begins with the first statement in the <c>main()</c> method,
      labeled with line number 1.
      This statement declares a variable of type <c>OneRowNim</c> named <c>game</c> and calls a constructor <c>OneRowNim()</c> to create and initialize it.
      The constructor,
      which in this case is a default <image width="73%" source="chptr02/gstate1.png"/> constructor,
      causes control to shift to the declaration of the instance variables <c>nSticks</c> and <c>player</c> in statements 2 and 3, and assigns them initial values of 7 and 1 respectively.
      Control then shifts back to the second statement in <c>main()</c>, which has the label 4.
      At this point, <c>game</c> refers to an instance of the
<c>OneRowNim</c> class with an initial state shown in Figure<nbsp/>2.23.
      Executing statement 4 causes control to shift to the <c>report()</c> method where statements 5 and 6 use <c>System.out.println()</c> to write the following statements to the console.
    </p>
 <program language="java"><input>
Number of sticks left: 7
    Next turn by player 1
 </input></program>
    <p>
      Control shifts back to statement 7 in the <c>main()</c> method,
      which calls the <c>takeThree()</c> method,
      sending control to the first statement of that method.
      Executing statement 8 causes <m>3</m> to be subtracted from the <c>int</c> value stored in the instance variable
<c>nSticks</c> of <c>game</c>, leaving the value of <m>4</m>.<nbsp/>Executing statement 9 subtracts the value stored in the <c>player</c> variable,
      which is <m>1</m>, from <m>3</m> and assigns the result
      (the value <m>2</m>)
      back to
<c>player</c>. The state of the object <c>game</c>, at this point,
      is shown in Figure<nbsp/>2.24.
      <image width="73%" source="chptr02/gstate2.png"/> \caption{The state of <c>game</c> after line 9 is executed. } Tracing the remainder of the program follows in a similar manner.
      Notice that the <c>main()</c> method calls <c>game.report()</c> four different times so that the two statements in the <c>report()</c> method are both executed on four different occasions.
      Note also that there is no call of <c>game.takeTwo()</c> in <c>main()</c>. As a result,
      the two statements in that method are never executed.
    </p>
  </subsection>
  <subsection>
    <title>Object-Oriented Design: Basic Principles</title>
    <p>
      We complete our discussion of the design and this first implementation of the <c>OneRowNim</c> class with a brief review of some of the object-oriented design principles that were employed in this example.
      <ul>
        <li>
          <p>
            <em>Encapsulation.
              <idx><h>Encapsulation Principle</h></idx>
          </em> The <c>OneRowNim</c> class was designed to encapsulate a certain state and a certain set of actions.
            It was designed to simulate playing the One Row Nim game.
            In addition, <c>OneRowNim</c>'s methods were designed to encapsulate the actions that make up their particular tasks.
            Information Hiding.<c>OneRowNim</c>'s instance variables, <c>nSticks</c> and <c>player</c> are declared <c>private</c> so other objects can only change the values of these variables with the public methods of a <c>OneRowNim</c> instance.
            The bodies of the public methods are also hidden from users of <c>OneRowNim</c> instances.
            An instance and its methods can be used without any knowledge of method definitions.
            Clearly Designed Interface.<c>OneRowNim</c>'s interface is defined in terms of the public methods.
            These methods constrain the way users can interact with <c>OneRowNim</c> objects and ensures that <c>OneRowNim</c> instances remain in a valid state.
            Those are the main purposes of a good interface.
            Generality and Extensibility.
            There is little in our design of OneRowNim that limits its use and its extensibility.
            Moreover, as we will see later,
            we can create several different kinds of user interfaces which interact with <c>OneRowNim</c> objects.
          </p>
        </li>
      </ul>
    </p>
    <p>
      The <c>OneRowNim</c> class has some obvious shortcomings that are a result of our decision to limit methods to those without parameters or return values.
      These shortcomings include:
      <ul>
        <li>
          <p>
            A <c>OneRowNim</c> object cannot communicate to another object the number of remaining sticks,
            which player makes the next turn,
            or whether the game is over.
            It can only communicate by writing a report to the console window.
          </p>
        </li>
        <li>
          <p>
            The <c>takeOne()</c>, <c>takeTwo()</c> and <c>takeThree()</c> methods all have similar definitions.
            It would be a better design if a single method could take away a specified number of sticks.
          </p>
        </li>
        <li>
          <p>
            There is no way to play a <c>OneRowNim</c> game starting with a different number of sticks than 7.
            It would be nice to have a way of playing a game that starts with any number of sticks.
          </p>
        </li>
        <li>
          <p>
            In order to for a user to play a <c>OneRowNim</c> game,
            a user interface class would need to be developed that would allow the user to receive information about the state of the game and to input moves to make.
          </p>
        </li>
      </ul>
    </p>
    <p>
      As we study other features of Java in the next two chapters,
      we will modify the <c>OneRowNim</c> class to address these identified shortcomings.
    </p>
  </subsection>
</section>