<section xml:id="fromthe-java-libraryand-file-input-optional">
<title>From the Java Library: <c>java.io.File</c> 
 and File Input (Optional)</title>


<introduction>
<p>
In addition to command-line and GUI user interfaces, there is one more
standard user interface, files. In this section we show how the <c>Scanner</c>
class, that was used in Chapter<nbsp/>2 for keyboard input, can also
read input from files. Reading input from
a file is relevant to only certain types of programming problems.
It is hard to imagine how a file would be used in playing the One Row Nim
game but a file might very well be useful to store a collection of riddles
that could be read and displayed by a Java program. We will develop such a
program later in this section.
</p>

<p>
Java has two types of files, <em>text files</em> and <em>binary files</em>.
A <term>text file</term> stores a sequence of characters and is the type of
file created by standard text editors like <em>NotePad</em> and <em>WordPad</em>
on a Windows computer or <em>SimpleText</em> on a Macintosh. A <term>binary file</term>
has a more general format that can store numbers and other data the way they are
<image width="73%" source="chptr04" />
stored in the computer. In this section we will consider only text files. Binary
files are considered in Chapter<nbsp/>11.
</p>
</introduction>


<subsection xml:id="fig-scanner2uml">
<title>File Input with the <c>File</c> and <c>Scanner</c> Classes</title>
<p>
An instance of the <c>java.io.File</c> class stores information that
a <c>Scanner</c> object needs to create an input stream that is connected
to the sequence of characters in a text file. A partial list of the
public methods of the <c>File</c> class is given in the UML class diagram
in Figure<nbsp/>4.26. We will need to use only the <c>File()</c>
constructor in this section. The <c>File</c> instance created with the
statement
</p>
<pre>
File theFile = new File("riddles.txt");
</pre>
<p>
<image width="73%" source="chptr04" />
</p>

<p>
will obtain and store information about the "riddles.txt" file in
the same directory as the java code being executed, if such a file
exists. If no such file exists, the <c>File</c> object stores
information needed to create such a file but does not create it. In
Chapter<nbsp/>11, we will describe how other objects can use a file object
to create a file in which to write data. If we wish to create a <c>File</c> object that describes a file in a directory other than the one
containing the Java program, we must call the constructor with a
string argument that specifies the file's complete path name<mdash/>that is,
one that lists the sequence of directories containing the file. In
any case, while we will not use it at this time, the <c>exists()</c>
method of a <c>File</c> instance can be used to determine whether or
not a file has been found with the specified name.
</p>

<p>
In order to read data from a file with a <c>Scanner</c> object we will
need to use methods that were not discussed in Chapter<nbsp/>2. An expanded
list of methods of the <c>Scanner</c> class is given in
Figure<nbsp/>4.27. Note the there is a <c>Scanner()</c> constructor with a
<c>File</c> object as an argument. Unlike the other <c>create()</c>
method that was used in Chapter<nbsp/>2, this <c>create()</c> throws an
exception that must be handled. The following code will create a <c>Scanner</c> object that will be connected to an input stream that can
read from a file:
</p>
<pre>
try
{   File theFile = new File("riddles.txt");
    fileScan = new Scanner(theFile);
    fileScan = fileScan.useDelimiter("\r\n");} catch (IOException e)
{    e.printStackTrace();} //catch()
</pre>
<p>
We will discuss the <c>try-catch</c> commands when exceptions
are covered in Chapter<nbsp/>10. Until then, the <c>try-catch</c> structures
can be copied exactly as above, if you wish to use a <c>Scanner</c>
object for file input. In the code above, the <c>useDelimiter()</c>
method has been used to set the <c>Scanner</c> object so that spaces
can occur in strings that are read by the <c>Scanner</c> object. For
the definition of a class to read riddles from a file, the above code
belongs in a constructor method.
</p>

<p>
After we create a <c>Scanner</c> object connected to a file, we can
make a call to <c>nextInt()</c>, <c>nextDouble()</c>, or <c>next()</c>
method to read, respectively, an integer, real number, or string from
the file. Unlike the strategy for using a <c>Scanner</c> object to get
keyboard input, it is suggested that you test to see if there is more
data in a file before reading it. This can be done with the <c>hasNext()</c>, <c>hasNextInt()</c>, and <c>hasNextDouble()</c> methods.
These methods return the value <c>true</c> if there are more data in the
file.
</p>

<p>
The program in <xref ref="fig-fileprog">Figure</xref>
is the complete listing of a class that reads riddles from a file
</p>
<figure xml:id="fig-fileprog" >
<caption>A program which reads riddles from a file and displays them.</caption>
\[26.5pc]
<pre>
import java.io.*;
import java.util.Scanner;
public class RiddleFileReader
{  private Scanner fileScan; // For file input
   private Scanner kbScan;   // For keyboard input

   public RiddleFileReader(String fName)
   {   kbScan = new Scanner(System.in);
       try
       {   File theFile = new File(fName);
           fileScan = new Scanner(theFile);
           fileScan = fileScan.useDelimiter("\r\n");
       } catch (IOException e)
       {    e.printStackTrace();
       } //catch()
   } //RiddleFileReader() constructor
   public Riddle readRiddle()
   {   String ques = null;
       String ans = null;
       Riddle theRiddle = null;
       if (fileScan.hasNext())
           ques = fileScan.next();
       if (fileScan.hasNext())
       {   ans =  fileScan.next();
           theRiddle = new Riddle(ques, ans);
       } // if
       return theRiddle;
   } // readRiddle()
   public void displayRiddle(Riddle aRiddle)
   {   System.out.println(aRiddle.getQuestion());
       System.out.print("Input any letter to see answer:");
       String str = kbScan .next();  //Ignore KB input
       System.out.println(aRiddle.getAnswer());
       System.out.println();
   } // displayRiddle()
   public static void main(String[] args)
   {   RiddleFileReader rfr =
           new RiddleFileReader("riddles.txt");
       Riddle riddle = rfr.readRiddle();
       while (riddle != null)
       {   rfr.displayRiddle(riddle);
           riddle = rfr.readRiddle();
       } // while
   } //main()}  //RiddleFileReader class
</pre>

</figure>
<p>
and displays them. Note that, in the body of the method <c>readRiddles()</c>,
the statements:
</p>
<pre>
String ques = null;
String ans = null;
Riddle theRiddle = null;
</pre>
<p>
make explicit the fact that variables that refer to objects
are assigned <c>null</c> as a value when they are declared. The statements:
</p>
<pre>
if (fileScan.hasNext())
    ques = fileScan.next();
if (fileScan.hasNext())
{   ans =  fileScan.next();
    theRiddle = new Riddle(ques, ans);}
</pre>
<p>
will read <c>String</c>s into the variables <c>ques</c> and <c>ans</c>
only if the file contains lines of data for them. Otherwise the
<c>readRiddle()</c> method will return a <c>null</c> value. The <c>main()</c>
method uses this fact to terminate a <c>while</c> loop when it runs out
of string data to assign to <c>Riddle</c> questions and answers. There is
a separate method, <c>displayRiddle()</c> using a separate instance of
<c>Scanner</c> attached to the keyboard to display the question
of a riddle before the answer.
</p>

<p>
The contents of the "riddles.txt" file should be a list of riddles
with each question and answer on a separate line.
For example The following three riddles saved in a text file would form
a good example to test the <c>RiddleFileReader</c> class.
</p>

<p>
\[27pc]
</p>
<pre>
What is black and white and red all over?
  An embarrassed zebra
  What is black and white and read all over?
  A newspaper
  What other word can be made with the letters of ALGORITHM?
  LOGARITHM
</pre>
<p>
When the <c>main()</c> method is executed, the user will see output
in the console window that looks like:
</p>
<pre>
What is black and white and red all over?
  Input any letter to see answer: X
  An embarrassed zebra
  
  What is black and white and read all over?
  Input any letter to see answer:
</pre>
<p>
Files are covered in depth in Chapter<nbsp/>11. Information on writing data to a file
and reading data from a file without using the <c>Scanner</c> class can be found in
that chapter.
</p>

<p>
\secEXRHone{Self-Study Exercises}
<ol>
<li><p>Modify the <c>RiddleFileReader</c> class to create a program 
<c>NumberFileReader</c>that opens
a file named "numbers.txt" and reports the sum of the squares of the integers 
in the file.  Assume that the file "numbers.txt" contains a list of integers 
in which each integer is on a separate line. The program should print the
sum of the squares in the <c>System.out</c> console window. In this case, 
there is no need to have a method to display the data being read or
a <c>Scanner</c> object connected to the keyboard.  You will want a constructor
method and a method that reads the numbers and computes the sum of squares.</p></li>
</ol>
</p>

<p>
\secSMH{Chapter Summary}
\secKTH{Technical Terms}
\begin{KT}
</p>

<p>
abstract class
</p>

<p>
abstract interface
</p>

<p>
abstract method
</p>

<p>
AWT
</p>

<p>
binary file
</p>

<p>
buffer
</p>

<p>
command-line interface
</p>

<p>
container
</p>

<p>
control element
</p>

<p>
event-driven programming
</p>

<p>
event loop
</p>

<p>
graphical user interface (GUI)
</p>

<p>
helper method
</p>

<p>
inheritance
</p>

<p>
input operation
</p>

<p>
input stream
</p>

<p>
interface
</p>

<p>
layout manager
</p>

<p>
listener
</p>

<p>
model-view-controller (MVC) architecture
</p>

<p>
output operation
</p>

<p>
output stream
</p>

<p>
stream
</p>

<p>
Swing
</p>

<p>
text file
</p>

<p>
top-level container
</p>

<p>
user interface
</p>

<p>
wrapper class
\end{KT}
</p>

<p>
\secSMHtwo{Summary of Important Points}
<ul>
<li><p>An input operation is any action that transfers data from the
user to the computer's main memory via one of the computer's input
devices. An output operation is any action that transfers data
from the computer's main memory to one of the computer's output
devices.</p></li>
<li><p>The user interface is that part of the program that handles the
input and output interactions between the user and the program.  As an
interface, it limits or constrains the manner in which the user can
interact with the program.</p></li>
<li><p>In a command-line interface, user input is taken from the
keyboard, and the program's output is displayed on some kind of
console.</p></li>
<li><p>A buffer is a portion of main memory where input is held until
it is needed by the program. Using a buffer between the keyboard and
the program allows you to use the Backspace key to delete a
character.</p></li>
<li><p>A wrapper class contains methods for converting primitive
data into objects and for converting data from one type to another.</p></li>
<li><p>Designing appropriate prompts is an important aspect of
designing a good user interface.</p></li>
<li><p>I/O operations must watch out for certain types of I/O
exceptions.</p></li>
<li><p>GUI programming involves a computational model known as 
event-driven programming, which means that GUI programs react to
events that are generated mostly by the user's interactions with
elements in the GUI.</p></li>
<li><p>Java has two packages of GUIs, the older <c>java.awt</c>
and the newer <c>javax.swing</c>.</p></li>
<li><p>Swing components are based on the object-oriented
model-view-controller (MVC) architecture.</p></li>
<li><p>The <c>extends</c> keyword is used to specify subclass/superclass
relationships in the Java class hierarchy.</p></li>
<li><p>A top-level container is a GUI container that cannot be
added to another container; it can only have components added to it.
All GUI programs must be contained in a top-level container.</p></li>
<li><p>There are generally three kinds of GUI components, corresponding
to the three main functions of a user interface: input, output, and
control.</p></li>
<li><p>Events are handled by special objects called listeners. A
listener is a specialist that listens constantly for a certain type of
event.</p></li>
<li><p>An interface is a special Java class that contains only
methods and constants (final variables).</p></li>
</ul>
</p>

<p>
{
    \rule[0pt]{40.5pc}{0.5pt}}

    \epsfig{file=../commonart/eoc2text.eps,
            height=4pt,width=40.5pc,clip=}

    \marginpar{
      
      { 
        \uppercase{Solutions to 
Self-Study Exercises}
      }
    }
        
\newcommand{\secANSHleft}{
    

{\rule[0pt]{40.5pc}{0.5pt}}

    \epsfig{file=../commonart/eoc2text.eps,
            height=4pt,width=40.5pc,clip=}

    \marginpar{
      { 
         
         \uppercase{Solutions to 
Self-Study Exercises}
      }
    }
        

\newcommand{\secKTH}[1]{{
    #1}

}

\newcommand{\secLREXRH}[1]{{
    {
\uppercase{#1}}}

}

\def\endpracticedesign{

{\rule[0pt]{27pc}{0.5pt}}

}

\newcommand{\secHsix}[1]{{#1}

}

\newcommand{\secHfive}[2]{{
    \rule[16pt]{27pc}{0.5pt}
    
    }\newcommand{\secBXsixHone}[1]{{#1}

}

\newcommand{\secBXsixBTHleft}[1]{
    {\rule[0pt]{44.45pc}{2pt}}

    \marginpar{
    
    
    }\newcommand{\secBXsevenHone}[1]{{#1}

}\newcommand{\secCOBH}[1]
{{\uppercase{#1}}
    

    }\newcommand{\secCOLH}[1]
{{\uppercase{#1}}
    

}\newcommand{\secSMH}[1]{
   

{\rule[0pt]{40.5pc}{1pt}}

   \epsfig{file=../commonart/eoc2text.eps,
         height=4pt,width=40.5pc,clip=}

   

   \marginpar{
     
     {
       
       
       \uppercase{#1}
     }
   }
   }
\newcommand{\secSMHleft}[1]{
   

{\rule[0pt]{40.5pc}{0.5pt}}

   \epsfig{file=../commonart/eoc2text.eps,
            height=4pt,width=40.5pc,clip=}

   

   \marginpar{
       
        
        \uppercase{#1}
    }
    }


\newcommand{\secSMHtwo}[1]{{
    #1}

}\newcommand{\secEXRHone}[1]{{\uppercase{#1}}

}



\newcounter{EXRLLcount}

    {

\marginpar{{From
 the Java Library}

    #1}
    
    }
    

   {\begin{minipage}{26pc}}{\end{minipage}}

    
    \rule[0pt]{27pc}{#1}
  }
 

 
 \begin{minipage}[t]{26pc}
     {
  \end{minipage}
 }

    
    \rule[0pt]{#2}{#1}
  }
 

 
 \begin{minipage}[t]{#2}
     {
  \end{minipage}
 }


    
    
    \rule[0pt]{40pc}{#1}
  }
 

 
 
\begin{minipage}[t]{26pc}
     {
  \end{minipage}
 }

    
    
    \rule[0pt]{#2}{#1}
<ul>
<li><p>The following modification of the <c>GreeterApp</c> class
is an implementation of the High Low Game:

\[29pc]
<pre>
%%%[basicstyle=\scriptsize]
public class HighLowApp 
{ private KeyboardReader reader;
  private int secretNumber;

  public HighLowApp() 
  { reader = new KeyboardReader();
    secretNumber = 1 + (int)(Math.random() * 100);
  } // HighLowApp() constructor
    
  public void run() 
  { int userGuess = -1;
    reader.display("Guess my secret number between 1 and 100.");
    while (userGuess != secretNumber)
    {   reader.prompt("Please input your guess here > ");
      userGuess = reader.getKeyboardInteger();
      if (userGuess > secretNumber)
        reader.display("Your guess was too high.");
      if (userGuess &lt; secretNumber)
        reader.display("Your guess was too low.");
    } // while
    reader.display("Congratulations. Your guess was correct.");
  } // run()
     
  public static void main(String args[]) 
  { HighLowApp app = new HighLowApp();
    app.run();
  } // main()}// HighLowApp
</pre></p></li>
<li><p>The following modification of <c>GreeterGUI</c> eliminates the <c>JButton</c>.
<pre>
%%%[basicstyle=\scriptsize]
import javax.swing.*;
import java.awt.*;
import java.awt.event.*;

public class GreeterGUI2 extends JFrame 
                         implements ActionListener 
{ private JTextArea display;
  private JTextField inField;
  private Greeter greeter;
      
  public GreeterGUI2(String title) 
  {   greeter = new Greeter();  
      buildGUI();
      setTitle(title);
      pack();
      setVisible(true);
  } // GreeterGUI2()
  private void buildGUI() 
  {   Container contentPane = getContentPane();
      contentPane.setLayout(new BorderLayout());
      display = new JTextArea(10,30);
      inField = new JTextField(10);
      inField.addActionListener(this);
      JPanel inputPanel = new JPanel();
      inputPanel.add(new 
              JLabel("Input your name and type enter: "));
      inputPanel.add(inField);
      contentPane.add("Center", display);
      contentPane.add("South", inputPanel);
  } // buildGUI()
  public void actionPerformed(ActionEvent e) 
  {   if (e.getSource() == inField) 
      {   String name = inField.getText();
          display.append(greeter.greet(name) + "\n");
      }
  } // actionPerformed()} // GreeterGUI2
</pre></p></li>
<li><p>Java code that prints out the sum of the
squares of a set of integers read from a file named "numbers.txt":
<pre>
%%%[basicstyle=\scriptsize]
import java.io.*;
import java.util.Scanner;

public class NumberFileReader
{   private Scanner fileScan; // For file input
   
    public NumberFileReader(String fName)
    {   try
        {   File theFile = new File(fName);
            fileScan = new Scanner(theFile);
        } catch (IOException e)
        {    e.printStackTrace();
        } //catch()
    } //NumberFileReader() 

    public void readNumbers()
    {   int num = 0;      // To store integers read
        int sum = 0:      // To store sum of squares
        while (fileScan.hasNextInt()) 
        {   num = fileScan.nextInt();
            sum = sum + num * num;
        } // while
        System.out.println("The sum of squares = " + sum);
    } // readNumbers()

    public static void main(String[] args)
    {   NumberFileReader nfr =
            new NumberFileReader("numbers.txt");
        nfr.readNumbers()
    } //main()}  //NumberFileReader
</pre></p></li>
</ul>
</p>

<p>
\marginpar{<term>Note:</term> For programming exercises, <term>first</term> draw
a UML class diagram describing all classes and
their inheritance relationships and/or associations.}
</p>

<ol>
<li><p>Fill in the blanks in each of the following sentences:
</p>

<ol>
<li><p>A method that lacks a body is an \rule{40pt}{0.5pt} method.</p></li>
<li><p>An \rule{40pt}{0.5pt} is like a class except that it contains
only instance methods, no instance variables.</p></li>
<li><p>In a Java class definition a class can \rule{40pt}{0.5pt}
a class and \rule{40pt}{0.5pt}  an interface.</p></li>
<li><p>Classes and methods not defined in a program must be \rule{40pt}{0.5pt}
 from the Java class library.</p></li>
<li><p>A subclass of a class inherits that class's \rule{40pt}{0.5pt} instance variables and instance methods.</p></li>
<li><p>An object can refer to itself by using the \rule{40pt}{0.5pt} keyword.</p></li>
<li><p>The <c>JButton</c>, <c>JTextField</c>, and <c>JComponent</c> classes
are defined in the  \rule{40pt}{0.5pt} package.</p></li>
<li><p>Java GUIs utilize a form of control known as \rule{40pt}{0.5pt}  programming.</p></li>
<li><p>When the user clicks on a program's <c>JButton</c>, an
  \rule{40pt}{0.5pt} will automatically be generated.</p></li>
<li><p>Two kinds of objects that generate <c>ActionEvent</c>s are \rule{40pt}{0.5pt} and
\rule{40pt}{0.5pt} .
  JButtons, <c>JTextField</c>s, and
<c>JLabel</c>s are all subclasses of \rule{40pt}{0.5pt} .</p></li>
<li><p>The <c>JFrame</c> class is a subclass of  \rule{40pt}{0.5pt} .</p></li>
<li><p>If java class intends to handle <c>ActionEvent</c>s, it must
implement the \rule{40pt}{0.5pt} interface.</p></li>
<li><p>When an applet is started, its  \rule{40pt}{0.5pt} method is called
automatically.</p></li>
</ol>
concepts:
<ol>
Class and <em>interface</em>.
  Extending a class and <em>instantiating an object</em>.
  Defining a method and <em>implementing a method</em>.
<li><p>A <c>protected</c> method and a <c>public</c> method.</p></li>
<li><p>A <c>protected</c> method and a <c>private</c> method.</p></li>
<li><p>An <c>ActionEvent</c> and an <c>ActionListener()</c> method.</p></li>
</ol>
</li>
<li><p>Draw a hierarchy chart to represent the following situation.
There are lots of languages in the world.  English, French, Chinese,
and Korean are examples of natural languages.  Java, C, and C++ are
examples of formal languages.  French and Italian are considered
romance languages, while Greek and Latin are considered classical
languages.</p></li>
<li><p>Arrange the Java library classes mentioned in the
Chapter Summary into their proper hierarchy, using the
<c>Object</c> class as the root of the hierarchy.</p></li>
<li><p>Look up the documentation for the <c>JButton</c> class
on Sun's Web site:
<pre>
http://java.sun.com/j2se/1.5.0/docs/api/
</pre>
List the signatures of all its constructors.</p></li>
<li><p>Suppose we want to set the text in our program's <c>JTextField</c>.
What method should we use and where is this method defined? (<em>Hint</em>:
Look up the documentation for <c>JTextField</c>. If no appropriate
method is defined there, see if it is inherited from a superclass.)</p></li>
<li><p>Does a <c>JApplet</c> have an <c>init()</c> method? Explain.</p></li>
<li><p>Does a <c>JApplet</c> have an <c>add()</c> method? Explain.</p></li>
<li><p>Does a <c>JButton</c> have an <c>init()</c> method? Explain.</p></li>
<li><p>Does a <c>JButton</c> have an <c>add()</c> method? Explain.</p></li>
<li><p>Suppose you type the URL for a <q>Hello, World!</q> applet
into your browser.  Describe what happens<mdash/>that is, describe the
processing that takes place in order for the applet to display <q>Hello,
World!</q> in your browser.</p></li>
<li><p>Suppose you have a program containing a <c>JButton</c>
named <c>button</c>. Describe what happens, in terms of
Java's event handling model, when the user clicks  the
button.</p></li>
<li><p>Java's <c>Object</c> class contains a public method, <c>toString()</c>,
which returns a string that represents this object.  Because every class
is a subclass of <c>Object</c>, the <c>toString()</c> method can be used
by any object.   Show how you would invoke this method for a <c>JButton</c>
object named <c>button</c>.</p></li>
<li><p>The  JFrame that follows contains a semantic error in
its <c>SomeFrame()</c> constructor.  The error will cause the
<c>actionPerformed()</c> method never to display <q>Clicked</q>
even though the user clicks the button in the
JFrame.  Why?  (<em>Hint</em>: Think scope!)
<pre>
public class SomeFrame extends JFrame
                        implements ActionListener
{
     // Declare instance variables
    private JButton button;

    public JFrame()
    {   
       // Instantiate the instance variable
        JButton button = new JButton("Click me");
        add(button);
        button.addActionListener(this);
    } // init()

    public void actionPerformed(ActionEvent e)
    {
        if (e.getSource() == button)
           System.out.println("Clicked");
    } // actionPerformed()} // SomeFrame
</pre></p></li>
<li><p>What would be output by the following program?
<pre>
public class SomeFrame2 extends JFrame
{
  // Declare instance variables
  private JButton button;
  private JTextField field;

  public SomeFrame()
  { 
    // Instantiate instance variables
    button = new JButton("Click me");
    add(button);
    field = new JTextField("Field me");
    add(field);
    System.out.println(field.getText() + button.getText());
  } // init()
  public static void main(String[] args) {
     SomeFrame2 frame = new SomeFrame2();
     frame.setSize(400,400);
     frame.setVisible(true);
  }} // SomeFrame2}
</pre></p></li>
<li><p>Design and implement a GUI that has a <c>JButton</c>, a 
<c>JTextField</c>, and a <c>JLabel</c> and then uses the <c>toString()</c> method to display each object's string representation.</p></li>
<li><p>The <c>JButton</c> class inherits a <c>setText(String s)</c> 
from its <c>AbstractButton()</c> superclass. Using that method, design
and implement a GUI that has a single button labeled initially, <q>The
Doctor is out.</q>  Each time the button is clicked, it should toggle
its label to, <q>The Doctor is in</q> and vice versa.</p></li>
<li><p>Design and implement a GUI that contains
two <c>JButton</c>s, initially labeled, <q>Me first!</q> and <q>Me next!</q>
Each time the user clicks either button, the labels on both buttons
should be exchanged.  (<em>Hint</em>: You don't need an if-else statement
for this problem.)</p></li>
<li><p>Modify the GUI in the previous exercise so that it contains
three <c>JButton</c>s, initially labeled <q>First,</q> <q>Second,</q> and
<q>Third.</q> Each time the user clicks one of the buttons, the labels
on the buttons should be rotated.  Second should get first's label,
third should get second's, and first should get third's label.</p></li>
<li><p>Design and implement a GUI that contains a
<c>JTextField</c> and two <c>JButton</c>s, initially labeled <q>Left</q>
and <q>Right.</q> Each time the user clicks a button, display its
label in the <c>JTextField</c>. A <c>JButton()</c>'s label can be gotten
with the <c>getText()</c> method.</p></li>
<li><p>You can change the size of a <c>JFrame</c> by using the
<c>setSize(int h, int v)</c> method, where <em>h</em> and <em>v</em> give its horizontal and vertical
dimensions pixels.  Write a GUI application that 
contains two <c>JButton</c>s, labeled <q>Big</q> and <q>Small.</q> Whenever
the user clicks on small, set the <c>JFrame's</c> dimensions to
200 <times/> 100, and whenever the user clicks on big, set the dimensions
to 300 <times/> 200.</p></li>
<li><p>Rewrite your solution to the previous exercise
so that it uses a single button whose label is toggled appropriately
each time it is clicked.  Obviously, when the <c>JButton</c> is
labeled <q>Big,</q> clicking it should give the <c>JFrame</c> its big
dimensions.


  Challenge: Design and write a Java GUI application that allows 
the user to change the <c>JFrame</c>'s background color to one of three choices,
indicated by buttons.  Like all other Java <c>Component</c>s, <c>JFrame</c>'s
have an associated background color, which can be set by the following
commands:
<pre>
setBackground(Color.red);
setBackground(Color.yellow);
</pre>
The <c>setBackground()</c> method is defined in the
<c>Component</c> class, and 13 primary colors<mdash/><c>black</c>, <c>blue</c>,
<c>cyan</c>, <c>darkGray</c>, <c>gray</c>, <c>green</c>, <c>lightGray</c>, 
\mbox{magenta} , <c>orange</c>, <c>pink</c>, <c>red</c>, <c>white</c>, <c>yellow</c><mdash/>are 
defined in the <c>java.awt.Color</c> class.

\secEXRHone{Additional Exercises}</p></li>
<li><p>Given the classes with the following headers
<pre>
public class Animal ...
public class DomesticAnimal extends Animal ...
public class FarmAnimal extends DomesticAnimal...
public class HousePet extends DomesticAnimal...
public class Cow extends FarmAnimal ...
public class Goat extends FarmAnimal ...
public class DairyCow extends Cow ...
</pre>
draw a UML class diagram representing the hierarchy
created by these \mbox{declarations.}</p></li>
<li><p>Given the preceding hierarchy of classes, which of the following
are legal assignment statements?
<pre>
DairyCow dc = new FarmAnimal();
FarmAnimal fa = new Goat();
Cow c1 = new DomesticAnimal();
Cow c2 = new DairyCow();
DomesticAnimal dom = new HousePet();
</pre></p></li>
</ol>
</subsection>

</section>
