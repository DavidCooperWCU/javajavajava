<section xml:id="the-binary-search-tree-data-structure">
<title>The Binary Search Tree Data Structure</title>
<p>
To gain some appreciation of what binary search trees are and why they
are useful in implementing the <c>Set</c> and <c>Map</c> interfaces, let's
make a few comments about implementing very simple versions of these
structures.
</p>

<p>
Like a linked list, a <em>binary tree</em> is a data structure consisting
of a collection of nodes that are linked together by references from
one node to another. However, unlike a linked list, each node in a
binary tree contains references to two other other nodes, (<c>left</c>
and <c>right</c>), corresponding to the left- and right-subtrees
growing out of a particular node. A <em>subtree</em> is a tree that is
part of larger tree. This creates a tree-like structure, as shown in
Figure<nbsp/>16.36. Note that some of the references to other nodes might
</p>
<figure xml:id="fig-btree-ds" >
<caption>A binary search tree of <c>PhoneTreeNode</c>s.</caption>
<image width="73%" source=".." />
</figure>
<p>
be null. The trunk of the tree corresponds to the node labeled <c>root</c>. In computer science, trees are almost always drawn upside down.
Thus the trunk of the tree, <c>root</c>, is at the top of the figure.
</p>

<p>
If we assume that the objects contained in a tree are from a class
that implements the <c>Comparable</c> interface, then a <term>binary
search tree</term> is a binary tree in which the objects are ordered so that
the object at a particular node is greater than the objects stored in
its left subtree and less than the objects stored in its right
subtree.
</p>

<p>
Figure<nbsp/>16.36 shows a binary search tree with the phone list data that
we have used throughout the chapter. Objects are compared by
comparing the names alphabetically. From the figure it is easy to see
that searching for a object should start at the root of the tree. At
each node, examining the name at the node will tell you whether you
have found the object there. Otherwise, by checking the name at the
node, you can decide which subtree the data could be in, and you can
traverse either left or right through each level of the tree. One can
deduce that if the tree is balanced<mdash/>that is, if at most nodes the
size of the left subtree is about the same size as the right
subtree<mdash/>searching the tree much faster than searching a linked
list. This is one of the main advantages of using a binary search tree
over a linked list.
</p>

<p>
The <c>TreeSet</c> and <c>TreeMap</c> classes implement sophisticated
algorithms for inserting and removing data from a tree, which
guarantees that the tree remains relatively balanced. The details of
these algorithms are beyond the scope of this book, but would be a
subject of study in a standard <em>Data Structures and Algorithms</em>
course.
</p>

<p>
We will conclude this subsection by giving a brief outline of an
implementation of a simple binary search tree that stores our phone
list data. Like our <c>LinkedList</c> example, you need to define a
node class and a tree class. The node class with unimplemented
methods, would look like:
</p>
<pre>
public class PhoneTreeNode {
   private String name;
   private String phone;
   private PhoneTreeNode left;
   private PhoneTreeNode right;

   public PhoneTreeNode(String nam, String pho){ }
   public void setData(String nam, String pho){ }
   public String getName(){ }
   public boolean contains(String nam, String pho){ }
   public void insert(String nam, String pho){ }
   //other methods} // PhoneTreeNode
</pre>
<p>
The tree structure itself contains a reference to a node:
</p>
<pre>
public class PhoneTree {
  private PhoneTreeNode root;

  public PhoneTree(){ }
  public boolean contains(String nam, String pho){ }
  public void insert(String nam, String pho){ }
  //other methods} // PhoneTreeNode
</pre>
<p>
We will implement only the two <c>contains()</c> methods.
The <c>PhoneTree</c> version is very simple:
</p>
<pre>
public boolean contains(String nam, String pho){
    if (root == null) return false;
    else return root.contains(nam, pho);} // contains() in PhoneTree
</pre>
<p>
The implementation of the <c>contains()</c> method of <c>PhoneTreeNode</c> is only slightly more involved.
</p>
<pre>
public boolean contains(String nam, String pho){
    if (name.equals(nam))
        return true;
    else if(name.compareTo(nam) &lt; 0) { // name &lt; nam
        if (right == null) return false;
        else return right.contains(nam, pho);
    } else { { // name > nam}
        if (left == null) return false;
        else return left.contains(nam, pho);
    }} // contains() in PhoneTreeNode
</pre>
<p>
\secSMHleft{Chapter Summary}
</p>

<p>
In this chapter, we have given you a brief introduction to the concept of a
dynamic data structure and tried to illustrate how they work and why
they are useful for organizing and managing large amounts of data. We
also introduced you to an important new language feature introduced in
Java 5.0, the concept of generic types. Obviously, we have only
scratched the surface of the important topic of data structures and
the algorithms used to manage them. For a broader and deeper
treatment of this subject, you will have to take a <em>Data
Structures and Algorithms</em> course, which is a fundamental course in
most computer science curricula.
</p>

<p>
\secKTH{Technical Terms}
\begin{KT}
Abstract Data Type (ADT)
</p>

<p>
binary search tree
</p>

<p>
data structure
</p>

<p>
dequeue
</p>

<p>
dynamic structure
</p>

<p>
enqueue
</p>

<p>
first-in<ndash/>first-out (FIFO)
</p>

<p>
generic type
</p>

<p>
Java collections framework
</p>

<p>
key
</p>

<p>
last-in<ndash/>first-out (LIFO)
</p>

<p>
link
</p>

<p>
list
</p>

<p>
linked list
</p>

<p>
pop
</p>

<p>
push
</p>

<p>
queue
</p>

<p>
reference
</p>

<p>
self-referential object
</p>

<p>
stack
</p>

<p>
static structure
</p>

<p>
traverse
</p>

<p>
value
</p>

<p>
vector
</p>

<p>
\end{KT}
</p>

<p>
\secSMHtwo{Summary of Important Points}
<ul>
<li><p>A <em>data structure</em> is used to organize
data and make them more efficient to process.  An array is
an example of a <em>static structure</em>, since its size
does not change during a program's execution.  A vector
is an example of a <em>dynamic structure</em>, one whose
size can grow and shrink during a program's execution.</p></li>
<li><p>A <em>linked list</em> is a linear structure in which
the individual nodes of the list are joined together by references.  A
<em>reference</em> is a variable that refers to an object.  Each node in
the list has a <em>link</em> variable that refers to another node.  An
object that can refer to the same kind of object is said to be <em>self-referential</em>.</p></li>
<li><p>The <c>Node</c> class is an example of a self-referential class.
It contains a link variable that refers to a <c>Node</c>. By assigning
references to the link variable, <c>Node</c>s can be chained together
into a linked list.  In addition to their link variables, <c>Node</c>s
contain data variables, which should be accessible through public
methods.</p></li>
<li><p>Depending on the use of a linked list, nodes can be
inserted at various locations in the list: at the head,
the end, or in the middle of the list.</p></li>
<li><p>Traversal algorithms must be used to access the elements
of a singly linked list.  To traverse a list you start at the
first node and follow the links of the chain until you
reach the desired node.</p></li>
<li><p>Depending on the application, nodes can be
removed from the front, rear, or middle of a linked list.
Except for the front node, traversal algorithms are used to locate the
desired node.</p></li>
<li><p>In developing list algorithms, it is important to test
them thoroughly.  Ideally, you should test every possible combination
of insertions and removals that the list can support.  Practically, you
should test every independent case of insertions and removals that the
list supports.</p></li>
<li><p>An <em>Abstract Data Type (ADT)</em> is a concept
that combines two elements: A collection of data, and the operations
that can be performed on the data.  For the list ADT, the data are the
values (<c>Object</c>s or <c>int</c>s) contained in the nodes that make
up the list, and the operations are insertion, removal, and tests of
whether the list is empty.</p></li>
<li><p>In designing an ADT, it's important to provide a public
interface that can be used to access the ADT's data.  The ADT's
implementation details should not matter to the user and should,
therefore, be hidden.  A Java class definition, with its <c>public</c>
and <c>private</c> aspects, is perfectly suited to implement an ADT.</p></li>
<li><p>A <em>stack</em> is a list that allows insertions and removals
only at the front of the list.  A stack insertion is called a <em>push</em> and a removal is called a <em>pop</em>. The first element in a
stack is usually called the top of the stack.   The <c>Stack</c> ADT can
easily be defined as a subclass of <c>List</c>. Stacks are used
for managing the method call and return in most programming languages.</p></li>
<li><p>A <em>queue</em> is a list that only allows insertions at the
rear and removals from the front of a list.  A queue insertion is
called <em>enqueue</em>, and a removal is called <em>dequeue</em>.  The
<c>Queue</c> ADT can easily be defined as a subclass of <c>List</c>. Queues
are used for managing the various lists used by the CPU scheduler<mdash/>such as
the ready, waiting, and blocked queues.</p></li>
<li><p>A <em>binary search tree</em> is a binary tree in which the ordered data
stored at any node is greater than all data stored in the left 
subtree and is less
than all data stored in the right subtree.</p></li>
</ul>
</p>

<p>
{
    \rule[0pt]{40.5pc}{0.5pt}}

    \epsfig{file=../commonart/eoc2text.eps,
            height=4pt,width=40.5pc,clip=}

    \marginpar{
      
      { 
        \uppercase{Solutions to 
Self-Study Exercises}
      }
    }
        
\newcommand{\secANSHleft}{
    

{\rule[0pt]{40.5pc}{0.5pt}}

    \epsfig{file=../commonart/eoc2text.eps,
            height=4pt,width=40.5pc,clip=}

    \marginpar{
      { 
         
         \uppercase{Solutions to 
Self-Study Exercises}
      }
    }
        

\newcommand{\secKTH}[1]{{
    #1}

}

\newcommand{\secLREXRH}[1]{{
    {
\uppercase{#1}}}

}

\def\endpracticedesign{

{\rule[0pt]{27pc}{0.5pt}}

}

\newcommand{\secHsix}[1]{{#1}

}

\newcommand{\secHfive}[2]{{
    \rule[16pt]{27pc}{0.5pt}
    
    }\newcommand{\secBXsixHone}[1]{{#1}

}

\newcommand{\secBXsixBTHleft}[1]{
    {\rule[0pt]{44.45pc}{2pt}}

    \marginpar{
    
    
    }\newcommand{\secBXsevenHone}[1]{{#1}

}\newcommand{\secCOBH}[1]
{{\uppercase{#1}}
    

    }\newcommand{\secCOLH}[1]
{{\uppercase{#1}}
    

}\newcommand{\secSMH}[1]{
   

{\rule[0pt]{40.5pc}{1pt}}

   \epsfig{file=../commonart/eoc2text.eps,
         height=4pt,width=40.5pc,clip=}

   

   \marginpar{
     
     {
       
       
       \uppercase{#1}
     }
   }
   }
\newcommand{\secSMHleft}[1]{
   

{\rule[0pt]{40.5pc}{0.5pt}}

   \epsfig{file=../commonart/eoc2text.eps,
            height=4pt,width=40.5pc,clip=}

   

   \marginpar{
       
        
        \uppercase{#1}
    }
    }


\newcommand{\secSMHtwo}[1]{{
    #1}

}\newcommand{\secEXRHone}[1]{{\uppercase{#1}}

}



\newcounter{EXRLLcount}

    {

\marginpar{{From
 the Java Library}

    #1}
    
    }
    

   {\begin{minipage}{26pc}}{\end{minipage}}

    
    \rule[0pt]{27pc}{#1}
  }
 

 
 \begin{minipage}[t]{26pc}
     {
  \end{minipage}
 }

    
    \rule[0pt]{#2}{#1}
  }
 

 
 \begin{minipage}[t]{#2}
     {
  \end{minipage}
 }


    
    
    \rule[0pt]{40pc}{#1}
  }
 

 
 
\begin{minipage}[t]{26pc}
     {
  \end{minipage}
 }

    
    
    \rule[0pt]{#2}{#1}
<ul>
<li><p><pre>
Node node = new Node(new String("Hello"));
</pre></p></li>
<li><p><pre>
Node node = new Node(new Student("William"));
</pre></p></li>
<li><p><pre>
PhoneListNode newNode = 
         new PhoneListNode("Bill C", "111-202-3331");
nodeptr.setNext(newNode);
</pre></p></li>
<li><p>The following condition is too general.  It will cause the 
loop to exit as soon
as a nonnull node is encountered, whether or not the node matches the
one being sought.
<pre>
((current.getNext() != null) || 
                  (!current. getName().equals(name)))
</pre></p></li>
<li><p>The <c>PhoneList</c> program will generate the
following output, which has been edited slightly
to improve its readability:
<pre>
Phone Directory
---------------
Roger M 997-0020    Roger W 997-0086    Rich P  997-0010
Jane M  997-2101    Stacy K 997-2517
Looking up numbers by name
   Roger M 997-0020
   Rich P 997-0010
   Stacy K 997-2517
   Sorry. No entry for Mary P
Removed Rich P  997-0010
Phone Directory
---------------
Roger M 997-0020    Roger W 997-0086   Jane M  997-2101
Stacy K 997-2517
Removed Roger M 997-0020
Phone Directory
---------------
Roger W 997-0086    Jane M  997-2101    Stacy K 997-2517
Removed Stacy K 997-2517
Phone Directory
---------------
Roger W 997-0086    Jane M  997-2101
Removed Jane M  997-2101
Phone Directory
---------------
Roger W 997-0086
Sorry. No entry for Jane M
Phone Directory
---------------
Roger W 997-0086
Removed Roger W 997-0086
Phone Directory
---------------
Phone list is empty
</pre></p></li>
<li><p>Executing the following method calls will test
whether it is possible to insert items into a
list after items have been removed:
<pre>
// Create and insert some nodes
PhoneList list = new PhoneList();
list.insert(new PhoneListNode("Roger M", "997-0020"));
list.insert(new PhoneListNode("Roger W", "997-0086"));
System.out.println(list.remove("Roger M") );
list.insert(new PhoneListNode("Rich P", "997-0010"));
System.out.println(list.remove("Roger W"));
list.insert(new PhoneListNode("Jane M", "997-2101"));
list.insert(new PhoneListNode("Stacy K", "997-2517"));
System.out.println(list.remove("Jane M"));
System.out.println(list.remove("Stacy K"));
list.print();
       // List should be empty
</pre></p></li>
<li><p>The  List ADT program will produce the
following output:
<pre>
Generic List
---------------
Hello, World!
8647
Roger M 997-0020
Jane M 997-2101
Stacy K 997-2517
  Removed Stacy K 997-2517
Generic List:
Hello, World!
8647
Roger M 997-0020
Jane M 997-2101
  Removed Jane M 997-2101
Generic List:
Hello, World!
8647
Roger M 997-0020
  Removed Hello, World!
Generic List:
8647
Roger M 997-0020
</pre></p></li>
<li><p>Executing the following method calls will test
whether it is possible to insert items into a
  <c>List</c> after items have been removed:
<pre>
// Create and insert some nodes
List list = new List();
list.insertAtFront(new PhoneRecord("Roger M", "997-0020"));
list.insertAtFront(new PhoneRecord("Roger W", "997-0086"));
System.out.println("Current List Elements");
list.print();
Object o = list.removeLast();   // Remove last element
list.insertAtFront(o); // Insert at the front of the list
System.out.println("Current List Elements");
list.print();
o = list.removeFirst();
System.out.println("Removed " + o.toString());
o = list.removeFirst();
System.out.println("Removed " + o.toString());
list.insertAtRear(o);
System.out.println("Current List Elements");
list.print();       // List should have one element
</pre></p></li>
<li><p>The <c>peek()</c> method should just return the
first node without deleting it:
<pre>
public Object peek() {
     return head;}
</pre></p></li>
<li><p>The <c>peekLast()</c> method can be modeled after the
<c>List.removeLast()</c> method:
<pre>
public Object peekLast() {
  if (isEmpty())
    return null;
  else {
    Node current = head;         // Start at head of list
    while (current.getNext() != null)// Find end of  list
      current = current.getNext();
      return  current;                 // Return last node
    }} // peekLast()
</pre></p></li>
<li><p>The following class tests the <c>java.util.Stack&lt;E&gt;</c> class:
<pre>
import java.util.*;
public class StackTest{
public static void main( String argv[] ) {
   Stack&lt;Character> stack = new Stack&lt;Character>();
   String string = "Hello this is a test string";

   System.out.println("String: " + string);
   for (int k = 0; k &lt; string.length(); k++)
     stack.push(new Character(string.charAt(k)));

   Character ch = null;
   String reversed = "";
   while (!stack.empty()) {
     ch  = stack.pop();
     reversed = reversed + ch.charValue();
   }
   System.out.println("Reversed String: " + reversed);} // main()} // StackTest class
</pre></p></li>
</ul>
</p>

<ol>
<li><p>Explain the difference between each of the following pairs of terms:
<ol>
Stack and <em>queue</em>.
  Static structure and <em>dynamic structure</em>.
  Data structure and <em>Abstract Data Type</em>.
  Push and <em>pop</em>.
  Enqueue and <em>dequeue</em>.
  Linked list and <em>node</em>.
</ol>

</p>
\marginpar{<term>Note:</term> For programming 
exercises, <term>first</term> draw
a UML class diagram describing all classes and
their inheritance relationships and/or associations.}</li>
<li><p>Fill in the blanks.
<ol>
<li><p>An <em>Abstract Data Type</em> consists of two
main parts: \rule{40pt}{0.5pt} and \rule{40pt}{0.5pt} .</p></li>
<li><p>An object that contains a variable that refers to an object of
the same class is a \rule{40pt}{0.5pt} .</p></li>
<li><p>One application for a \rule{40pt}{0.5pt} is to manage the method
call and returns in a computer program.</p></li>
<li><p>One application for a \rule{40pt}{0.5pt} is to balance the parentheses
in an arithmetic expression.</p></li>
<li><p>A \rule{40pt}{0.5pt} operation is one that starts at the beginning
of a list and processes each element.</p></li>
<li><p>A vector is an example of a \rule{40pt}{0.5pt} data structure.</p></li>
<li><p>An array is an example of a \rule{40pt}{0.5pt} data structure.</p></li>
<li><p>By default, the initial value of a reference variable
is \rule{40pt}{0.5pt} .</p></li>
</ol></p></li>
<li><p>Add a <c>removeAt()</c> method to the <c>List</c> class to
return the object at a certain index location in the list.  This method
should take an <c>int</c> parameter, specifying the object's position
in the list, and it should return an <c>Object</c>.</p></li>
<li><p>Add an <c>insertAt()</c> method to the <c>List</c> class that
will insert an object at a certain position in the list.  This method
should take two parameters, the <c>Object</c> to be inserted, and an
<c>int</c> to designate where to insert it.   It should return a
<c>boolean</c> to indicate whether the insertion was successful.</p></li>
<li><p>Add a <c>removeAll()</c> method to the <c>List</c> class.
This <c>void</c> method should remove all the members of the list.</p></li>
<li><p>Write an <c>int</c>  method named <c>size()</c> that returns the
number of elements in a <c>List</c>.</p></li>
<li><p>Write an <c>boolean</c>  method named <c>contains(Object o)</c> 
that returns
<c>true</c> if its <c>Object</c> parameter is contained in the list.</p></li>
<li><p>The <em>head</em> of a list is the first element in the list.
The <em>tail</em> of a list consists of all the elements except the
head.  Write a method named <c>tail()</c> that returns a reference to
the tail of the list.  Its return value should be <c>Node</c>.</p></li>
<li><p>Write a program that uses the <c>List</c> ADT
to store a list of 100 random floating-point numbers.   Write methods
to calculate the average of the numbers.</p></li>
<li><p>Write a program that uses the <c>List</c> ADT
to store a list of <c>Student</c> records, using a variation of the Student
class defined in Chapter 11.  Write a method to calculate the mean
grade point average for all students in the list.</p></li>
<li><p>Write a program that creates a copy of a <c>List</c>.
It is necessary to copy each node of the list.  This will require that
you create new nodes that are copies of the nodes in the original
list.  To simplify this task, define a copy constructor for your node
class and then use that to make copies of each node of the list.</p></li>
<li><p>Write a program that uses a <c>Stack</c> ADT to determine
if a string is a palindrome<mdash/>spelled the same way backward and
forward.</p></li>
<li><p>Design and write a program that uses a <c>Stack</c> to determine
whether a parenthesized expression is well-formed.  Such an expression
is well formed only if there is a closing parenthesis for each opening
parenthesis.</p></li>
<li><p>Design and write a program that uses <c>Stack</c>s to determine
whether an expression involving both parentheses and square brackets
is well formed.</p></li>
<li><p>Write a program that links two lists together, appending
the second list to the end of the first list.</p></li>
<li><p>Design a <c>Stack</c> class that uses
a <c>Vector</c> instead of a linked list to store its elements.  This
is the way Java's <c>Stack</c> class is defined.</p></li>
<li><p>Design a <c>Queue</c> class that uses
a <c>Vector</c> instead of a linked list to store its elements.</p></li>
<li><p>Write a program that uses the <c>List&lt;E&gt;</c> and <c>LinkedList&lt;E&gt;</c> classes to store a list of <c>Student</c> records, using
a variation of the <c>Student</c> class defined in Chapter 11. Write a
method to calculate the mean grade point average for all students in
the list.</p></li>
<li><p>Write an implementation of the <c>insert()</c> method of the <c>PhoneTree</c> class described at the end of this chapter.</p></li>
<li><p>Write an implementation of the <c>insert()</c> method of the <c>PhoneTreeNode</c> class described at the end of this chapter.

  Challenge: Design a <c>List</c> class, similar in
functionality to the one we designed in this chapter, that uses an
<em>array</em> to store the list's elements.  Set it up so that the middle
of the array is where the first element is placed.  That way you can still
insert at both the front and rear of the list.   One limitation of this
approach is that, unlike a linked list, an array has a fixed
size.  Allow the user to set the initial size of the array in a
constructor, but if the array becomes full, don't allow any further
insertions.

  Challenge: Add a method to the program in the previous
exercise that lets the user increase the size of the array used to
store the list.

  Challenge: Recursion is a useful technique for list processing.
Write recursive versions of the <c>print()</c> method and the lookup-by-name
method for the <c>PhoneList</c>. (<em>Hint</em>: The base case in processing
a list is the empty list.  The recursive case should handle the head of
the list and then recurse on the tail of the list.  The tail of the
list is everything but the first element.)


  Challenge: Design an <c>OrderedList</c> class.  An ordered
list is one that keeps its elements in order.  For example, if it's an
ordered list of integers, then the first integer is less than or equal
to the second, the second is less than or equal to the third, and so
on.  If it's an ordered list of employees, then perhaps the employees
are stored in order according to their social security numbers.  The
<c>OrderedList</c> class should contain an <c>insert(Object o)</c>
method that inserts its object in the proper order.  One major
challenge in this project is designing your class so that it will work
for any kind of object.  (<em>Hint:</em> Define an <c>Orderable</c> interface
that defines an abstract <c>precedes()</c> method.  Then
define a subclass of <c>Node</c> that implements <c>Orderable</c>. This
will let you compare any two <c>Node</c>s to see which one comes before
the other.)</p></li>
</ol>

<p>
\begin{appendix}
</p>
</section>
