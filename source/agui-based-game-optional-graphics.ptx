<section xml:id="agui-based-game-optional-graphics">
  <title>A GUI-Based Game (Optional Graphics)</title>
  <introduction>
    <p>
      Most modern computer games do not use a command-line interface.
      This section addresses this shortcoming by expanding our <c>ComputerGame</c> hierarchy so that it works with Graphical User Interfaces (GUIs) as well as Command-Line User Interfaces (CLUIs).
    </p>
    <p>
      The Sliding Tile Puzzle is a puzzle game.
      It is played by one player, a human.
      The puzzle consists of six tiles arranged on a board containing seven spaces.
      Three of the tiles are labeled <em>L</em>
      and three are labeled <em>R</em>.
      Initially the tiles are arranged as <em>RRR_LLL</em>.
      In other words,
      the <em>R</em> tiles are arranged to the left of the <em>L</em> tiles,
      with the blank space in the middle.
      The object of the puzzle is to rearrange the tiles into <em>LLL_RRR</em>.
      The rules are that tiles labeled
      <em>R</em> can only move right.
      Tiles labeled <em>L</em> can only move left.
      Tiles may move directly into the blank space or they can jump over one tile into the blank space.
    </p>
    <p>
      Our purpose in this section is to develop a GUI that plays this game.
      An appropriate GUI is shown <xref ref="fig-capture">Figure</xref>.
      Here the tiles and the blank space are represented by an array of buttons.
      To make a move the user clicks on the 'tile' he or she wishes to move.
      The GUI will assume that the user wants to move that tile into the blank space.
      If the proposed move is legal,
      the GUI will carry out the move.
      Otherwise, it will just ignore it.
      For example, if the user were to click on the third <em>R</em>
      button from the left, a legal move,
      the GUI would rearrange the labels on the buttons so that their new configuration would be <em>RR_RLLL</em>.
      On the other hand,
      if the user were to click on the rightmost <em>L</em> button,
      the GUI would ignore that move, because it is illegal.
    </p>
    <figure xml:id="fig-capture">
      <caption>The Sliding Tile Puzzle.</caption>
      <image width="73%" source="captureGUI.eps"/>
    </figure>
  </introduction>
  <subsection xml:id="fig-GUIplayable">
    <title>The <c>GUIPlayableGame</c>Interface</title>
    <p>
      How should we extend our game-playing hierarchy to accommodate GUI-based games?
      As we learned in Chapter<nbsp/>4,
      one difference between GUI-based applications and CLUI-based applications,
      is the locus of control.
      In a CLUI-based application,
      control resides in the computational object which,
      for games, is the game object.
      That's why the <c>play()</c> method in our CLUI-based games contains the game's control loop.
      By contrast,
      control resides in the GUI's event loop in GUI-based applications.
      That's why, we learned how to manage Java's event hierarchy in Chapter<nbsp/>4.
      Thus, in the GUI shown in <xref ref="fig-capture">Figure</xref>,
      the GUI will <em>listen</em> and take <em>action</em>
      when the user clicks one of its buttons.
    </p>
    <p>
      However, given that control will reside in the GUI, there is still a need for communication between the GUI and the game object.
      In the CLUI-based games,
      we have used the <c>CLUIPlayableGame</c> interface to manage the communication between the game and the user interface.
      We will follow the same design strategy in this case.
      Thus, we will design a <c>GUIPlayableGame</c> interface that can be implemented by any game that wishes to use a GUI (Fig.<nbsp/>9.36).
    </p>
    <p>
      What method(s) should this interface contain?
      One way to answer this question is to think about the type of interaction that must take place when the user clicks one of the tiles.
      If the user clicks the third <em>R</em> button,
      the GUI should pass this information to the game.
      The game should then decide whether or not that is a legal move and communicate this back to the GUI. Assuming it is a legal move,
      the game should also update its representation of the game's state to reflect that the tile array has changed.
      And it should somehow make communicate the game's state to the GUI. <image width="73%" source="GUIplayable.eps"/>
    </p>
    <p>
      Because it is impossible to know in advance just what form of data a game's moves might take,
      we will use Java <c>String</c> s to communicate between the user interface and the game object.
      Thus, a method with the following signature will enable us to submit a <c>String</c> representing the user's move to the game and receive in return a <c>String</c> representing the game object's response to the move:
    </p>
<pre>
submitUserMove(String move): String;
</pre>
    <p>
      In addition to this method,
      a GUI interface could use the
<c>reportGameState()</c> and <c>getGamePrompt()</c> methods that are part of the <c>IGame</c> interface.
      Th design shown in Figure<nbsp/>9.36 leads to the following definition for the <c>GUIPlayableGame</c> interface:
    </p>
<pre>
public interface GUIPlayableGame extends IGame {
    public String submitUserMove(String theMove);}
</pre>
    <p>
      Because it extends <c>IGame</c>, this interface inherits the
<c>getGamePrompt()</c> and <c>reportGameState()</c> from the <c>IGame</c> interface.
      The GUI should be able to communicate with any game that implements this interface.
    </p>
  </subsection>
  <subsection xml:id="fig-slidingpuzzle">
    <title>The <c>SlidingTilePuzzle</c></title>
    <p>
      Let's now discuss the design and details of the
<c>SlidingTilePuzzle</c> itself.
      Its design is summarized in Figure<nbsp/>9.37.
      Most of the methods should be familiar to you,
      because the design closely follows the design we employed in the <c>WordGuess</c> example.
      It has implementations of inherited methods from the <c>ComputerGame</c> class and the <c>GUIPlayableGame</c> interface.
    </p>
    <p>
      We will represent the sliding tile puzzle in a one-dimensional array of <c>char</c>. We will store the puzzle's solution in a Java <c>String</c> and we will use an <c>int</c> variable to keep track of where the blank space is in the array.
      This leads to the following class-level declarations:
    </p>
<pre>
private char puzzle[] = {'R','R','R',' ','L','L','L'};
 private String solution = "LLL RRR";
 private int blankAt = 3;
</pre>
    <p>
      <image width="73%" source="slidingtilepuzzle.eps"/> Note how we initialize the <c>puzzle</c> array with the initial configuration of seven characters.
      Taken together, these statements initialize the puzzle's state.
    </p>
    <p>
      Because a puzzle is a one-person game and our sliding tile puzzle will be played by a human,
      this leads to a very simple constructor definition:
    </p>
<pre>
public SlidingTilePuzzle() {
     super(1);
 }
</pre>
    <p>
      We call the <c>super()</c> constructor (<c>ComputerGame()</c>) to create a one-person game.
    </p>
    <p>
      The puzzle's state needs to be communicated to the GUI as a <c>String</c>. This is the purpose of the <c>reportGameState()</c> method:
    </p>
<pre>
public String reportGameState() {
     StringBuffer sb = new StringBuffer();
     sb.append(puzzle);
     return sb.toString();
 }
</pre>
    <p>
      We use a <c>StringBuffer()</c> to convert the puzzle,
      a <c>char</c> array,
      into a <c>String</c>.
    </p>
    <p>
      The most important method for communicating with the GUI is the <c>submitUserMove()</c> method:
    </p>
<pre>
public String submitUserMove(String usermove) {
  int tile = Integer.parseInt(usermove);
  char ch = puzzle[tile];
  if (ch == 'L' AmPaMp
               (blankAt == tile-1 || blankAt == tile-2))
    swapTiles(tile,blankAt);
  else if (ch == 'R' AmPaMp
               (blankAt == tile+1 || blankAt == tile+2))
    swapTiles(tile,blankAt);
  else
    return "That's an illegal move.\n";
  return "That move is legal.\n";}
</pre>
    <p>
      This is the method that processes the user's move,
      which is communicated through the GUI. As we saw,
      the puzzle's 'tiles' are represented by an array of buttons in the GUI. The buttons are indexed 0 through 6 in the array.
      When the user clicks a button,
      the GUI should pass its index,
      represented as a <c>String</c> to the
<c>submitUserMove()</c> method.
      Given the index number of the tile that was selected by the user,
      this method determines if the move is legal.
    </p>
    <p>
      The <c>Integer.parseInt()</c> method is used to extract the tile's index from the method's parameter.
      This index is used to get a 'tile' from the <c>puzzle</c> array.
      The logic in this method reflects the rules of the game.
      If the tile is an <em>L</em>,
      then it can only move into a blank space that is either 1 or 2 spaces to its left.
      Similarly, an <em>R</em> tile can only move into a blank space that is 1 or 2 spaces to its right.
      All other moves are illegal.
      For legal moves,
      we simply swap the tile and the blank space in the array,
      a task handled by the <c>swap()</c> method.
      In either case,
      the method returns a string reporting whether the move was legal or illegal.
    </p>
    <p>
      <xref ref="fig-puzzlecode">Figure</xref>
      shows the full implementation for the <c>SlidingTilePuzzle</c>, the remaining details of which are straight forward.
    </p>
    <figure xml:id="fig-puzzlecode">
      <caption>Implementation of the <c>SlidingTilePuzzle</c> class.</caption>
<pre>
public class SlidingTilePuzzle extends ComputerGame
                            implements GUIPlayableGame {
  private char puzzle[] = {'R','R','R',' ','L','L','L'};
  private String solution = "LLL RRR";
  private int blankAt = 3;
  public SlidingTilePuzzle() { super(1); }
  public boolean gameOver() { // True if puzzle solved
    StringBuffer sb = new StringBuffer();
    sb.append(puzzle);
    return sb.toString().equals(solution);
  }
  public String getWinner() {
    if (gameOver())
      return "\nYou did it! Very Nice!\n";
    else return "\nGood try. Try again!\n";
  }
  public String reportGameState() {
    StringBuffer sb = new StringBuffer();
    sb.append(puzzle);
    return sb.toString();
  }
  public String getGamePrompt() {
    return "To move a tile, click on it.";
  } //prompt()
  public String submitUserMove(String usermove) {
    int tile = Integer.parseInt(usermove);
    char ch = puzzle[tile];
    if (ch=='L' AmPaMp (blankAt==tile-1 || blankAt==tile-2))
      swapTiles(tile,blankAt);
    else if (ch=='R' AmPaMp
                   (blankAt==tile+1 || blankAt==tile+2))
      swapTiles(tile,blankAt);
    else
      return "That's an illegal move.\n";
    return "That move is legal.\n";
  }
  private void swapTiles(int ti, int bl) {
    char ch = puzzle[ti];
    puzzle[ti] = puzzle[bl];
    puzzle[bl] = ch;
    blankAt = ti;   // Reset the blank
  }} //SlidingTilePuzzle
</pre>
    </figure>
  </subsection>
  <subsection xml:id="fig-slidingGUI">
    <title>The <c>SlidingGUI</c>Class</title>
    <p>
      Let's now implement a GUI that can be used to play the sliding tile puzzle.
      We will model the GUI itself after those we designed in Chapter<nbsp/>4.
    </p>
    <p>
      Figure<nbsp/>9.39 provides a summary of the design.
      As an implementor of the <image width="73%" source="slidingGUI.eps"/> <c>ActionListener</c> interface, <c>SlidingGUI</c> implements the <c>actionPerformed()</c> method,
      which is where the code that controls the puzzle is located.
      The main data structure is an array of seven <c>JButton</c> s, representing the seven tiles in the puzzles.
      The buttons' labels will reflect the state of the puzzle.
      They will be rearranged after every legal move by the user.
      The <c>reset</c> button is used to reinitialize the game.
      This allows users to play again or to start over if they get stuck.
    </p>
    <p>
      The <c>puzzleState</c> is a <c>String</c> variable that stores the puzzle's current state,
      which is updated repeatedly from the <c>SlidingTilePuzzle</c> by calling its <c>reportGameState()</c> method.
      The private <c>labelButtons()</c> method will read the <c>puzzleState</c> and use its letters to set the labels of the GUI's buttons.
    </p>
    <p>
      The implementation of <c>SlidingGUI</c> is shown in <xref ref="fig-GUIsource">Figure</xref>.
      Its constructor and <c>buildGUI()</c> methods are responsible for setting up the GUI. We use of a <c>for</c> loop in <c>buildGUI()</c> to create the <c>JButton</c> s, associate an
<c>ActionListener</c> with them,
      and add them to the GUI. Except for the fact that we have an array of buttons,
      this is very similar to the GUI created in Chapter<nbsp/>4.
      Recall that associating an <c>ActionListener</c> with the buttons allows the program to respond to button clicks in its <c>actionPerformed()</c> method.
    </p>
    <p>
      Note how an instance of the <c>SlidingTilePuzzle</c> is created in the constructor,
      and how its state is retrieved and stored in the <c>puzzleState</c> variable:
    </p>
<pre>
puzzleState = sliding.reportGameState();
</pre>
    <p>
      The <c>labelButtons()</c> method transfers the letters in <c>puzzleState</c> onto the buttons.
    </p>
    <figure xml:id="fig-GUIsource">
      <caption>Implementation of the <c>SlidingGUI</c> class.</caption>
<pre>
import javax.swing.*;
import java.awt.*;
import java.awt.event.*;
public class SlidingGUI extends JFrame implements ActionListener {
  private JButton tile[] = new JButton[7];
  private JButton reset = new JButton("Reset");
  private SlidingTilePuzzle sliding;
  private String puzzleState;
  private Label label;
  private String prompt = "Goal: [LLL RRR]. " +
    " Click on the tile you want to move." +
    " Illegal moves are ignored.";
  public SlidingGUI(String title) {
    sliding = new SlidingTilePuzzle();
    buildGUI();
    setTitle(title);
    pack();
    setVisible(true);
  } // SlidingGUI()
  private void buildGUI() {
    Container contentPane = getContentPane();
    contentPane.setLayout(new BorderLayout());
    JPanel buttons = new JPanel();
    puzzleState = sliding.reportGameState();
    for (int k = 0; k &lt; tile.length; k++) {
      tile[k] = new JButton(""+puzzleState.charAt(k));
      tile[k].addActionListener(this);
      buttons.add(tile[k]);
    }
    reset.addActionListener(this);
    label = new Label(prompt);
    buttons.add(reset);
    contentPane.add("Center", buttons);
    contentPane.add("South", label);
  } // buildGUI()
  private void labelButtons(String s) {
    for (int k = 0; k &lt; tile.length; k++)
      tile[k].setText(""+ s.charAt(k));
  } // labelButtons()
  public void actionPerformed(ActionEvent e) {
    String result = "";
    if (e.getSource() == reset) { // Reset clicked?
      sliding = new SlidingTilePuzzle();
      label.setText(prompt);
    }
    for (int k = 0; k &lt; tile.length; k++) // Tile clicked?
      if (e.getSource() == tile[k])
        result = ((GUIPlayableGame)sliding).submitUserMove(""+ k);
    if (result.indexOf("illegal") != -1)
      java.awt.Toolkit.getDefaultToolkit().beep();
    puzzleState = sliding.reportGameState();
    labelButtons(puzzleState);
    if (sliding.gameOver())
      label.setText("You did it! Very nice!");
  } // actionPerformed()
  public static void main(String args[]) {
    new SlidingGUI("Sliding Tile Puzzle");
  } // main()} // SlidingGUI
</pre>
    </figure>
    <p>
      The most important method in the GUI is the <c>actionPerformed()</c> method.
      This method controls the GUI's actions and is called automatically whenever one of the GUI's buttons is clicked.
      First, we check whether the <c>reset</c> button has been clicked.
      If so, we reset the puzzle by creating a new instance of <c>SlidingTilePuzzle</c> and re-initializing the prompt label.
    </p>
    <p>
      Next we use a for loop to check whether one of the tile buttons has been clicked.
      If so, we use the loop index, <em>k</em>,
      as the tile's identification and submit this to the puzzle as the user's move:
    </p>
    <p>
      \[26.5pc]
    </p>
<pre>
if (e.getSource() == tile[k])
  result = ((GUIPlayableGame)sliding).submitUserMove(""+ k);
</pre>
    <p>
      The cast operation is necessary here because we declared
<c>sliding</c> as a <c>SlidingTilePuzzle</c> rather than as a <c>GUIPlayableGame</c>. Note also that we have to convert <em>k</em>
      to a <c>String</c> when passing it to <c>submitUserMove()</c>.
    </p>
    <p>
      As a result of this method call,
      the puzzle returns a <c>result</c>, which is checked to see if the user's move was illegal.
      If
<c>result</c> contains the word
      <q>illegal</q>, the computer beeps to signal an error:
    </p>
<pre>
if (result.indexOf("illegal") != -1)
    java.awt.Toolkit.getDefaultToolkit().beep();
</pre>
    <p>
      The <c>java.awt.Toolkit</c> is a class that contains lots of useful methods,
      including the <c>beep()</c> method.
      Note that no matter what action is performed, a reset or a tile click,
      we update <c>puzzleState</c> by calling <c>reportGameState()</c> and use it to relabel the tile buttons.
      The last task in the <c>actionPerformed()</c> method is to invoke the puzzle's <c>gameOver()</c> method to check if the user has successfully completed the puzzle.
      If so, we display a congratulatory message in the GUI's window.
    </p>
    <p>
      Finally, the <c>main()</c> for a GUI is very simple,
      consisting of a single line of code:
    </p>
<pre>
new SlidingGUI("Sliding Tile Puzzle");
</pre>
    <p>
      Once a <c>SlidingGUI</c> is created,
      with the title of
      <q>Sliding Tile Puzzle,</q>
      it will open a window and manage the control of the puzzle.
    </p>
    <p>
      \secSMH{Chapter Summary} \secKTH{Technical Terms} \begin{KT} array
    </p>
    <p>
      array initializer
    </p>
    <p>
      array length
    </p>
    <p>
      binary search
    </p>
    <p>
      data structure
    </p>
    <p>
      element
    </p>
    <p>
      element type
    </p>
    <p>
      insertion sort
    </p>
    <p>
      multidimensional array
    </p>
    <p>
      one-dimensional array
    </p>
    <p>
      polymorphic sort method
    </p>
    <p>
      selection sort
    </p>
    <p>
      sequential search
    </p>
    <p>
      sorting
    </p>
    <p>
      subscript
    </p>
    <p>
      two-dimensional array
    </p>
    <p>
      \end{KT}
    </p>
    <p>
      \secSMHtwo{Summary of Important Points}
      <ul>
        <li>
          <p>
            An <term>array</term>
              <idx><h>array</h></idx>
            is a named collection of contiguous storage locations,
            each of which stores a data item of the same data type.
            Each element of an array is referred to by a <em>subscript
              <idx><h>subscript</h></idx>
            </em><mdash/>that is, by its position in the array.
            If the array contains <em>N</em> elements,
            then its length is <em>N</em> and its indexes are <c>0, 1, <ellipsis /> N-1</c>.
          </p>
        </li>
        <li>
          <p>
            Array elements are referred to using the following subscript notation
            <em>arrayname[subscript]</em>,
            where <em>arrayname</em> is any valid identifier,
            and <em>subscript</em> is an integer value in the range 0 to <c>arrayname.length - 1</c>. The array's <c>length</c> instance variable can be used as a bound for loops that process the array.
          </p>
        </li>
        <li>
          <p>
            An <em>array declaration</em> provides the name and type of the array.
            An array instantiation uses the keyword <c>new</c> and causes the compiler to allocate memory for the array's elements:
<pre>
int arr[]; // Declare a one-dimensional array variable
arr = new int[15];// Allocate 15 int locations for it
</pre>
          </p>
        </li>
        <li>
          <p>
            Multidimensional arrays have arrays as their components:
<pre>
int twoDarr[][]; // Declare a two-dimensional array variable
twoDarr = new int[10][15]; // Allocate 150 int locations
</pre>
          </p>
        </li>
        <li>
          <p>
            An array's values must be initialized by assigning values to each array location.
            An <em>initializer
              <idx><h>array initializer</h></idx>
            </em> expression may be included as part of the array declaration.
          </p>
        </li>
        <li>
          <p>
            Insertion sort and selection sort are examples of array sorting algorithms.
            Both algorithms require several passes over the array.
          </p>
        </li>
        <li>
          <p>
            When an array is passed as a argument to a method,
            a reference to the array is passed rather than the entire array itself.
          </p>
        </li>
        <li>
          <p>
            Swapping two elements of an array,
            or any two locations in memory,
            requires the use of a temporary variable.
          </p>
        </li>
        <li>
          <p>
            Sequential search and binary search are examples of array searching algorithms.
            Binary search requires that the array be sorted.
          </p>
        </li>
        <li>
          <p>
            For multidimensional arrays,
            each dimension of the array has its own <c>length</c> variable.
          </p>
        </li>
        <li>
          <p>
            Inheritance and polymorphism are useful design features for developing a hierarchy of computer games.
          </p>
        </li>
      </ul>
    </p>
    <p>
      \secANSHleft
      <ul>
        <li>
          <p>
            Space (in bytes) allocated for each of the following?
            <ol>
              \scriptsize
              <li>
                <title>a</title>
                <p>
<c>int a[] = new int[5];       </c>{<c>   // 5 * 4 = 20 bytes</c>}
                </p>
              </li>
              <li>
                <title>b</title>
                <p>
<c>double b[] = new double[10];</c>{<c>   // 10 * 8 = 80 bytes</c>}
                </p>
              </li>
              <li>
                <title>c</title>
                <p>
<c>char c[] = new char[30];    </c>{<c>   // 30 * 2  = 60 bytes</c>}
                </p>
              </li>
              <li>
                <title>d</title>
                <p>
<c>String s[] = new String[10];</c>{<c>   // 10 * 4 (reference) = 40 bytes</c>}
                </p>
              </li>
              <li>
                <title>e</title>
                <p>
<c>Student s[] = new Student[5]; </c>{<c> // 5 * 4 (reference) = 20 bytes</c>}
                </p>
              </li>
            </ol>
          </p>
        </li>
        <li>
          <p>
            An array containing 10 <c>float</c> s, 1.0 to 10.0.
<pre>
float farr[] = {1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0};
</pre>
          </p>
        </li>
        <li>
          <p>
            Prints the first element of <c>farr</c>.
<pre>
System.out.println(farr[0]);
</pre>
          </p>
        </li>
        <li>
          <p>
            Assigns 100.0 to the last element in <c>farr</c>.
<pre>
farr[farr.length-1] = 100.0;
</pre>
          </p>
        </li>
        <li>
          <p>
            A loop to print all of the elements of <c>farr</c>.
<pre>
for (int j = 0; j &lt; farr.length; j++)
    System.out.println(farr[j]);
</pre>
          </p>
        </li>
        <li>
          <p>
            An array containing the first 100 square roots.
<pre>
double doubarr[] = new double[100];
for (int k = 0; k &lt; doubarr.length; k++)
    doubarr[k] = Math.sqrt(k+1);
</pre>
          </p>
        </li>
        <li>
          <p>
            Analyzing the letter frequencies in a file.
<pre>
import java.io.*;
import java.util.Scanner;
public static void main(String[] argv) {
  Scanner fileScan;  // To read lines of text from the file
  String str;        // To store the line of text
  AnalyzeFreq af = new AnalyzeFreq();
  try {         // Create a Scanner
    File theFile = new File("freqtest.txt");
    fileScan = Scanner.create(theFile);
    fileScan = fileScan.useDelimiter("\r\n"); //For Windows
    while (fileScan.hasNext()) { // Read and count
      str = fileScan.next();
      af.countLetters(str);
    } //while
    af.printArray(); // Print frequencies
  } catch (Exception e) {
     e.printStackTrace();
  } //catch()} //main()
</pre>
          </p>
        </li>
        <li>
          <p>
            Sort 24 18 90 1 0 85 34 18 with insertion sort.
<pre>
24 18 90 1  0  85 34 18 // Initial
  18 24 90 1  0  85 34 18 // Pass 1
  18 24 90 1  0  85 34 18 // Pass 2
  1  18 24 90 0  85 34 18 // Pass 3
  0  1  18 24 90 85 34 18 // Pass 4
  0  1  18 24 85 90 34 18 // Pass 5
  0  1  18 24 34 85 90 18 // Pass 6
  0  1  18 18 24 34 85 90 // Pass 7
</pre>
          </p>
        </li>
        <li>
          <p>
            Sort 24 18 90 1 0 85 34 18 with selection sort.
<pre>
24 18 90 1   0   85 34 18 // Initial
0  18 90 1   24  85 34 18 // Pass 1
0  1  90 18  24  85 34 18 // Pass 2
0  1  18 90  24  85 34 18 // Pass 3
0  1  18 18  24  85 34 90 // Pass 4
0  1  18 18  24  85 34 90 // Pass 5
0  1  18 18  24  34 85 90 // Pass 6
0  1  18 18  24  34 85 90 // Pass 7
</pre>
          </p>
        </li>
        <li>
          <p>
            Code to swap two <c>Student</c> s.
<pre>
Student tempStud = student1;
student1 = student2;
student2 = tempStud;
</pre>
          </p>
        </li>
        <li>
          <p>
            Implementation of the <c>selectionSort()</c>.
<pre>
public void selectionSort(int arr[]) {
    int smallest;      // Location of smallest element
    for (int k = 0; k &lt; arr.length-1; k++) {
        smallest = k;
        for (int j = k+1; j &lt; arr.length; j++)
            if (arr[j] &lt; arr[smallest])
                smallest = j;
        if (smallest != k) {   // Swap smallest and kth
            int temp = arr[smallest];
            arr[smallest] = arr[k];
            arr[k] = temp;
        } // if
    } // outer for
 } // selectionSort()
</pre>
          </p>
        </li>
        <li>
          <p>
            After <c>mystery(myArr,k)</c>, <c>myArr</c> will store 1,2,3,5,5 and
            <em>k</em> will store 3.
          </p>
        </li>
        <li>
          <p>
            Binary search trace for 21 in 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28:
<pre>
key  iteration  low   high    mid
--------------------------------------
21   0          0     13      6
21   1          7     13      10
21   2          7     9       8
21   3          9     9       9
21   4          10    9       failure
</pre>
          </p>
        </li>
        <li>
          <p>
            A two-dimensional array with 5 rows of 10 integers.
<pre>
int int2d[][] = new int[5][10];
</pre>
          </p>
        </li>
        <li>
          <p>
            Prints the last integer in the third row <c>int2d</c> and assigns 100 to its last element.
<pre>
System.out.println(int2d[2][9]);
int2d[4][9] = 100;
</pre>
          </p>
        </li>
        <li>
          <p>
            Prints all of the elements of <c>int2d</c>.
<pre>
for (int k = 0; k &lt; int2d.length; k++) {
     for (int j = 0; j &lt; int2d[k].length; j++)
         System.out.print( int2d[k][j] + " ");
     System.out.println();    // new line}
</pre>
          </p>
        </li>
        <li>
          <p>
            A <m>52\; \times \;7</m> two-dimensional array of <c>int</c>.
<pre>
int sales[][] = new int[52][7];
for (int k = 0; k &lt; sales.length; k++)
    for (int j= 0; j &lt; sales[k].length; j++)
        sales[k][j] = 0;
</pre>
          </p>
        </li>
        <li>
          <p>
            A method to calculate average number of newspapers per week.
<pre>
double avgWeeklySales(int arr[][]) {
    double total = 0;
    for (int k = 0; k &lt; arr.length; k++)
        for (int j= 0; j &lt; arr[k].length; j++)
            total += arr[k][j];
    return total/52;}
</pre>
          </p>
        </li>
        <li>
          <p>
            A method to calculate average Sunday newspapers.
<pre>
double avgSundaySales(int arr[][]) {
    double total = 0;
    for (int k = 0; k &lt; arr.length; k++)
        total += arr[k][6];
    return total/52;}
</pre>
          </p>
        </li>
        <li>
          <p>
            A <c>compareTo()</c> for <c>LetterFreq</c>.
<pre>
public int compareTo(Object lf) {
     LetterFreq  letFreq = (LetterFreq)lf;
     if (freq &lt; letFreq.getFreq())
         return -1;
     else if (freq > letFreq.getFreq())
         return +1;
     else return 0; //The frequencies must be equal.} //compareTo()
</pre>
          </p>
        </li>
        <li>
          <p>
            A <c>sort()</c> for <c>AnalyzeFreq</c>.
<pre>
public void sort() {
     java.util.Arrays.sort(freqArr);} //sort()
</pre>
          </p>
        </li>
        <li>
          <p>
            A new <c>AnalyzeFreq.main()</c> that uses <c>sort()</c>.
<pre>
public static void main(String[] argv) {
  AnalyzeFreq af = new AnalyzeFreq();
  af.countLetters("Now is the time for all good students" +
     " to study computer-related topics.");
  af.sort();
  af.printArray();} //main()
</pre>
          </p>
        </li>
      </ul>
    </p>
    <p>
      {\rule[0pt]{40.5pc}{0.5pt}} \epsfig{file=../commonart/eoc2text.eps,
      height=4pt,width=40.5pc,clip=} \marginpar{ { \uppercase{Exercises} } } \marginpar{<term>Note:</term>
      For programming exercises,
      <term>first</term> draw a UML class diagram describing all classes and their inheritance relationships and/or associations.}
    </p>
    <ol>
      <li>
        <p>
          Explain the difference between the following pairs of terms:
        </p>
        <ol>
          <li>
            <p>
              An <em>element</em> and an element <em>type</em>.
            </p>
          </li>
          <li>
            <p>
              A <em>subscript</em> and an <em>array element</em>.
            </p>
          </li>
          <li>
            <p>
              A <em>one-dimensional</em> array and
              <em>two-dimensional</em> array.
            </p>
          </li>
          <li>
            <p>
              An <em>array</em> and a <em>vector</em>.
            </p>
          </li>
          <li>
            <p>
              A <em>insertion sort</em> and a
              <em>selection sort</em>.
            </p>
          </li>
          <li>
            <p>
              A <em>binary search</em> and a <em>sequential search</em>.
            </p>
          </li>
        </ol>
      </li>
      <li>
        <p>
          Fill in the blanks.
          <ol cols="2">
            <li>
              <p>
                The process of arranging an array's elements into a particular order is known as \rule{40pt}{0.5pt} .
              </p>
            </li>
            <li>
              <p>
                One of the preconditions of the binary search method is that the array has to be \rule{40pt}{0.5pt} .
              </p>
            </li>
            <li>
              <p>
                An \rule{40pt}{0.5pt} is an object that can store a collection of elements of the same type.
              </p>
            </li>
            <li>
              <p>
                An \rule{40pt}{0.5pt} is like an array except that it can grow.
              </p>
            </li>
            <li>
              <p>
                For an array,
                its \rule{40pt}{0.5pt} is represented by an instance variable.
              </p>
            </li>
            <li>
              <p>
                An expression that can be used during array instantiation to assign values to the array is known as an \rule{40pt}{0.5pt} .
              </p>
            </li>
            <li>
              <p>
                A \rule{40pt}{0.5pt} is an array of arrays.
              </p>
            </li>
            <li>
              <p>
                A sort method that can be used to sort different types of data is known as a \rule{40pt}{0.5pt} method.
              </p>
            </li>
            <li>
              <p>
                To instantiate an array you have to use the \rule{40pt}{0.5pt} operator.
              </p>
            </li>
            <li>
              <p>
                An array of objects stores \rule{40pt}{0.5pt} to the objects.
              </p>
            </li>
            <li>
              <p>
                A <m>4 \times 4</m> array of <c>double</c> s.
              </p>
            </li>
            <li>
              <p>
                A <m>20 \times 5</m> array of <c>String</c> s.
              </p>
            </li>
            <li>
              <p>
                A <m>3 \times 4</m> array of <c>char</c> initialized to <sq>*</sq>;
              </p>
            </li>
            <li>
              <p>
                A <m>2 \times 3 \times 2</m> array of <c>boolean</c> initialized to true.
              </p>
            </li>
            <li>
              <p>
                A <m>3 \times 3</m> array of <c>Student</c> s.
              </p>
            </li>
            <li>
              <p>
                A <m>2 \times 3</m> array of <c>String</c> s initialized to
                <q>one,</q>
                <q>two,</q>
                and so on.
              </p>
            </li>
          </ol>
        </p>
      </li>
      <li>
        <p>
          Identify and correct the syntax error in each of the following expressions:
          <ol>
            <li>
              <p>
                <c>int arr = new int[15];</c>
              </p>
            </li>
            <li>
              <p>
                <c>int arr[] = new int(15);</c>
              </p>
            </li>
            <li>
              <p>
                <c>float arr[] = new [3];</c>
              </p>
            </li>
            <li>
              <p>
                <c>float arr[] = new float {1.0,2.0,3.0};</c>
              </p>
            </li>
            <li>
              <p>
                <c>int arr[] = {1.1,2.2,3.3};</c>
              </p>
            </li>
            <li>
              <p>
                <c>int arr[][] = new double[5][4];</c>
              </p>
            </li>
            <li>
              <p>
                <c>int arr[][] = { {1.1,2.2}, {3.3, 1} };</c>
              </p>
            </li>
          </ol>
        </p>
      </li>
      <li>
        <p>
          Evaluate each of the following expressions,
          some of which may be erroneous:
<pre>
int arr[] = { 2,4,6,8,10 };
</pre>
          <ol>
            <li>
              <p>
                <c>arr[4]</c>
              </p>
            </li>
            <li>
              <p>
                <c>arr[ arr.length ]</c>
              </p>
            </li>
            <li>
              <p>
                <c>arr[ arr[0] ]</c>
              </p>
            </li>
            <li>
              <p>
                <c>arr[ arr.length / 2 ]</c>
              </p>
            </li>
            <li>
              <p>
                <c>arr[ arr[1] ]</c>
              </p>
            </li>
            <li>
              <p>
                <c>arr[ 5 % 2 ]</c>
              </p>
            </li>
            <li>
              <p>
                <c>arr[ arr[ arr[0] ] ]</c>
              </p>
            </li>
            <li>
              <p>
                <c>arr[ 5 / 2.0 ]</c>
              </p>
            </li>
            <li>
              <p>
                <c>arr[ 1 + (int) Math.random() ]</c>
              </p>
            </li>
            <li>
              <p>
                <c>arr[ arr[3] / 2 ]</c>
              </p>
            </li>
          </ol>
        </p>
      </li>
      <li>
        <p>
          What would be printed by the following code segment?
<pre>
int arr[] = { 24, 0, 19, 21, 6, -5, 10, 16};
for (int k = 0; k &lt; arr.length; k += 2)
  System.out.println( arr[k] );
</pre>
        </p>
      </li>
      <li>
        <p>
          What would be printed by the following code segment?
<pre>
int arr[][] = { {24, 0, 19}, {21, 6, -5}, {10, 16, 3},
                                           {1, -1, 0} };
for (int j = 0; j &lt; arr.length; j++)
  for (int k = 0; k &lt; arr[j].length; k++)
    System.out.println( arr[j][k] );
</pre>
        </p>
      </li>
      <li>
        <p>
          What would be printed by the following code segment?
<pre>
int arr[][] = { {24, 0, 19}, {21, 6, -5}, {10, 16, 3},
                                           {1, -1, 0} };
for (int j = 0; j &lt; arr[0].length; j++)
    for (int k = 0; k &lt; arr.length; k++)
        System.out.println(arr[k][j]);
</pre>
        </p>
      </li>
      <li>
        <p>
          What's wrong with the following code segment,
          which is supposed to swap the values of the <c>int</c> variables,
          <em>n1</em> and <em>n2</em>?
<pre>
int temp = n1;
n2 = n1;
n1 = temp;
</pre>
        </p>
      </li>
      <li>
        <p>
          Explain why the following method does not successfully swap the values of its two parameters?
          Hint: Think about the difference between value and reference parameters.
<pre>
public void swapEm(int n1, int n2) {
    int temp = n1;
    n1 = n2;
    n2 = temp;}
</pre>
        </p>
      </li>
      <li>
        <p>
          Declare and initialize an array to store the following two-dimensional table of values:
<pre>
1   2   3   4
5   6   7   8
9  10  11  12
</pre>
        </p>
      </li>
      <li>
        <p>
          For the two-dimensional array you created in the previous exercise,
          write a nested for loop to print the values in the following order: 1 5 9 2 6 10 3 7 11 4 8 12.
          That is, print the values going down the columns instead of going across the rows.
        </p>
      </li>
      <li>
        <p>
          Define an array that would be suitable for storing the following values:
          <ol>
            <li>
              <p>
                The GPAs of 2,000 students.
              </p>
            </li>
            <li>
              <p>
                The lengths and widths of 100 rectangles.
              </p>
            </li>
            <li>
              <p>
                A week's worth of hourly temperature measurements,
                stored so that it is easy to calculate the average daily temperature.
              </p>
            </li>
            <li>
              <p>
                A board for a tic-tac-toe game.
              </p>
            </li>
            <li>
              <p>
                The names and capitals of the 50 states.
              </p>
            </li>
          </ol>
        </p>
      </li>
      <li>
        <p>
          Write a code segment that will compute the sum of all the elements of an array of <c>int</c>.
        </p>
      </li>
      <li>
        <p>
          Write a code segment that will compute the sum of the elements in a two-dimensional array of <c>int</c>.
        </p>
      </li>
      <li>
        <p>
          Write a method that will compute the average of all the elements of a two-dimensional array of <c>float</c>.
        </p>
      </li>
      <li>
        <p>
          Write a method that takes two parameters,
          an
<c>int</c> array and an integer,
          and returns the location of the last element of the array that is greater than or equal to the second parameter.
        </p>
      </li>
      <li>
        <p>
          Write a program that tests whether a <m>3\; \times \;3</m> array,
          input by the user, is a <em>magic square</em>.
          A magic square
            <idx><h>square</h></idx>
          is an <m>N\; \times\; N</m> matrix of numbers in which every number from 1 to <m>N^2</m> must appear just once,
          and every row, column,
          and diagonal must add up to the same total<mdash/>for example,
<pre>
6 7 2
1 5 9
8 3 4
</pre>
        </p>
      </li>
      <li>
        <p>
          Revise the program in the previous exercise so that it allows the user to input the dimensions of the array,
          up to <m>4\; \times\; 4</m>.
        </p>
      </li>
      <li>
        <p>
          Modify the <c>AnalyzeFreq</c> program so that it can display the relative frequencies of the 10 most frequent and 10 least frequent letters.
        </p>
      </li>
      <li>
        <p>
          The <em>merge sort</em> algorithm takes two collections of data that have been sorted and merges them together.
          Write a program that takes two 25-element <c>int</c> arrays,
          sorts them,
          and then merges them, in order,
          into one 50-element array.
          Challenge: Design and implement a <c>BigInteger</c> class that can add and subtract integers with up to 25 digits.
          Your class should also include methods for input and output of the numbers.
          If you're really ambitious, include methods for multiplication and division.
          Challenge: Design a data structure for this problem: As manager of Computer Warehouse,
          you want to track the dollar amount of purchases made by those clients that have regular accounts.
          The accounts are numbered from <c>0, 1, <ellipsis /> ,
N</c>. The problem is that you don't know in advance how many purchases each account will have.
          Some may have one or two purchases.
          Others may have 50 purchases.
        </p>
      </li>
      <li>
        <p>
          An <em>anagram</em> is a word made by rearranging the letters of another word.
          For example, <em>act</em> is an anagram of <em>cat</em>,
          and <em>aegllry</em> is an anagram of <em>allergy</em>.
          Write a Java program that accepts two words as input and determines if they are anagrams.
          Challenge: An <em>anagram dictionary</em>
          is a dictionary that organizes words together with their anagrams.
          Write a program that lets the user enter up to 100 words
          (in a <c>TextField</c>, say).
          After each word is entered, the program should display
          (in a <c>TextArea</c> perhaps)
          the complete anagram dictionary for the words entered.
          Use the following sample format for the dictionary.
          Here the words entered by the user were:
          <em>felt, left, cat, act, opt, pot,
          top.</em>
<pre>
act:  act cat
eflt:  felt left
opt:   opt pot top
</pre>
        </p>
      </li>
      <li>
        <p>
          Acme Trucking Company has hired you to write software to help dispatch its trucks.
          One important element of this software is knowing the distance between any two cities that it services.
          Design and implement a <c>Distance</c> class that stores the distances between cities in a two-dimensional array.
          This class will need some way to map a city name, <em>Boise</em>,
          into an integer that can be used as an array subscript.
          The class should also contain methods that would make it useful for looking up the distance between two cities.
          Another useful method would tell the user the closest city to a given city.
        </p>
      </li>
      <li>
        <p>
          Rewrite the <c>main()</c> method for the <c>WordGuess</c> example so that it allows the user to input the number of players and whether each players is a computer or a human.
          Use a <c>KeyboardReader</c>.
        </p>
      </li>
      <li>
        <p>
          Write a smarter version of the <c>WordGuesser</c> class that
          <q>knows</q>
          which letters of the English language are most frequent.
          HINT: Rather than using random guesses,
          store the player's guesses in a string in order of decreasing frequency: "ETAONRISHLGCMFBDGPUKJVWQXYZ".
        </p>
      </li>
      <li>
        <p>
          Write a CLUI version of the <c>SlidingTilePuzzle</c>. You will need to make modifications to the <c>SlidingTilePuzzle</c> class.
        </p>
      </li>
    </ol>
  </subsection>
</section>