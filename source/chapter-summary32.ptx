<section xml:id="chapter-summary32">
  <title>{Special Topic:} Are Computers Intelligent?</title>
  <p>
    Contemporary computer interfaces are largely visual and graphical,
    and many things we use a computer for,
    such as word processing, still require us to type.
    Will there come a day when instead of typing a letter or e-mail message,
    we'll be able to dictate it to our computer?
    Will computers eventually have the same kind of interface we have<mdash/>that is,
    will we someday be able to carry on conversations with our computers?
    Clearly, a
    <q>conversational interface</q>
    would require substantial intelligence on the part of the computer.
    Do computers have any chance of acquiring such intelligence?
  </p>
  <p>
    The question of machine intelligence or
    <em>artificial intelligence (AI)</em>
    has been the subject of controversy since the very first computers were developed.
    In 1950, in an article in the journal
    <em>Mind</em>, Alan Turing proposed the following test to settle the question of whether computers could be intelligent.
    Suppose you put a person and a computer in another room,
    and you let a human interrogate both with any kind of question whatsoever.
    The interrogator could ask them to parse a Shakespearian sonnet,
    or solve an arithmetic problem, or tell a joke.
    The computer's task would be to try to fool the interrogator into thinking that it was the human.
    And the (hidden) human's task would be to try to help the interrogator see that he or she was the human.
  </p>
  <p>
    Turing argued that someday computers would be able to play this game so well that interrogators would have no better than a 50/50 chance of telling which was which.
    When that day came, he argued,
    we would have to conclude that computers were intelligent.
  </p>
  <p>
    This so-called <em>Turing test</em>
    has been the subject of controversy ever since.
    Many of the founders of AI and many of its current practitioners believe that computation and human thinking are basically the same kind of process and that eventually computers will develop enough capability that we'll have to call them intelligent.
    Skeptics argue that even if computers could mimic our intelligence,
    there's no way they will be self-conscious and, therefore,
    they can never be truly intelligent.
    According to the skeptics, merely executing programs,
    no matter how clever the programs are,
    will never add up to intelligence.
  </p>
  <p>
    Computers have made some dramatic strides lately.
    In 1997, an IBM computer named Deep Blue beat world chess champion Gary Kasparov in a seven-game chess match.
    In 1998, a computer at Los Alamos National Laboratory proved a mathematical theorem that some of the best mathematicians were unable to prove for the past 40 years.
  </p>
  <p>
    However, despite these achievements,
    most observers would agree that computers are not yet capable of passing the Turing test.
    One area where computers fall short is in natural language understanding.
    Although computers are good at understanding Java and other computer languages,
    human languages are still too complex and require too much common sense knowledge for computers to understand them perfectly.
    Another area where computers still fall somewhat short is in speech recognition.
    However, an American company recently demonstrated a telephone that could translate between English and German
    (as well as some other languages)
    in real time.
    The device's only limitation was that its discourse was limited to the travel domain.
    As computer processing speeds improve,
    this limitation is expected to be only temporary.
    Thus, we may be closer than we think to having our
    <q>conversational user interface.</q>
  </p>
  <p>
    Natural language understanding,
    speech recognition, learning,
    perception, chess playing,
    and problem solving are the kinds of problems addressed in AI, one of the major applied areas of computer science.
    Almost every major research group in AI has a Web site that describes its work.
    To find some of these, just do a search for
    <q>artificial intelligence</q>
    and then browse through the links that are returned.
  </p>
  <p>
    \secSMHleft{Chapter Summary} \secKTH{Technical Terms} \begin{KT} adapter class
  </p>
  <p>
    callback design
  </p>
  <p>
    content pane
  </p>
  <p>
    containment hierarchy
  </p>
  <p>
    controller
  </p>
  <p>
    event model
  </p>
  <p>
    inner class
  </p>
  <p>
    layout manager
  </p>
  <p>
    lightweight component
  </p>
  <p>
    listener
  </p>
  <p>
    model
  </p>
  <p>
    model-view-controller (MVC)
  </p>
  <p>
    peer model
  </p>
  <p>
    pluggable look and feel
  </p>
  <p>
    view
  </p>
  <p>
    widget hierarchy
  </p>
  <p>
    \end{KT}
  </p>
  <p>
    \secSMHtwo{Summary of Important Points}
    <ul>
      <li>
        <p>
          Java provides two sets of Graphical User Interface (GUI) components,
          the Abstract Windowing Toolkit (AWT), which was part of Java 1.0 and the Swing component set,
          the GUI part of the Java Foundation Classes (JFC), introduced in JDK 1.1.
        </p>
      </li>
      <li>
        <p>
          Unlike their AWT counterparts, Swing components are written entirely in Java.
          This allows programs written in Swing to have a platform-independent look and feel.
          There are three built-in look-and-feel packages in Swing:
          a Windows style, a Unix-like Motif style,
          and a purely Java Metal style.
        </p>
      </li>
      <li>
        <p>
          Swing components are based on the
          <em>model-view-controller (MVC)</em> architecture,
          in which the component is divided into three separate objects:
          how it looks (<em>view</em>),
          what state it's in (<em>model</em>), and what it does
          (<em>controller</em>).
          The view and controller parts are sometimes combined into a single
          <em>user interface</em> class,
          which can be changed to create a customized look and feel.
        </p>
      </li>
      <li>
        <p>
          AWT components are based on the <em>peer model</em>,
          in which every AWT component has a peer in the native windowing system.
          This model is less efficient and more platform dependent than the MVC model.
        </p>
      </li>
      <li>
        <p>
          Java's <em>event model</em> is based on
          <em>event listeners</em>.
          When a GUI component is created,
          it is registered with an appropriate event listener,
          which takes responsibility for handling the component's events.
        </p>
      </li>
      <li>
        <p>
          A user interface combines four functions:
          guidance/information for the user,
          input, output, and control.
        </p>
      </li>
      <li>
        <p>
          Components in a GUI are organized into a
          <em>containment hierarchy</em>
          that is rooted at the top-level window. <c>JPanel</c> s and other
<c>Container</c> s can be used to organize the components into a hierarchy according to function or some other criterion.
        </p>
      </li>
      <li>
        <p>
          The top-level Swing classes<mdash/><c>JApplet</c>, <c>JDialog</c>,
<c>JFrame</c>, and <c>JWindow</c><mdash/>use a <em>content pane</em>
          as their component container.
        </p>
      </li>
      <li>
        <p>
          A GUI should minimize the number of input devices the user needs to manipulate,
          as well as the complexity the user needs to deal with.
          Certain forms of redundancy<mdash/>such as two independent but complete sets of controls<mdash/>are desirable because they make the interface more flexible and more widely applicable.
        </p>
      </li>
      <li>
        <p>
          A <em>layout manager</em> is an object that manages the size and arrangement of the components in a container.
          The AWT and Swing provide a number of built-in layouts,
          including flow, border, grid, and box layouts.
        </p>
      </li>
      <li>
        <p>
          A <em>radio button</em> is a toggle button that belongs to a group in which only one button from the group may be selected at the same time.
          A <em>checkbox</em> is a toggle button that always displays its state.
        </p>
      </li>
      <li>
        <p>
          A well-designed interface should reduce the chance of user error and should make it as easy as possible to recover from errors when they do occur.
        </p>
      </li>
    </ul>
  </p>
  <p>
    { \rule[0pt]{40.5pc}{0.5pt}} \epsfig{file=../commonart/eoc2text.eps,
    height=4pt,width=40.5pc,clip=} \marginpar{ { \uppercase{Solutions to Self-Study Exercises} } } \newcommand{\secANSHleft}{ {\rule[0pt]{40.5pc}{0.5pt}} \epsfig{file=../commonart/eoc2text.eps,
    height=4pt,width=40.5pc,clip=} \marginpar{ { \uppercase{Solutions to Self-Study Exercises} } } \newcommand{\secKTH}[1]{{ #1} } \newcommand{\secLREXRH}[1]{{ { \uppercase{#1}}} } \def\endpracticedesign{ {\rule[0pt]{27pc}{0.5pt}} } \newcommand{\secHsix}[1]{{#1} } \newcommand{\secHfive}[2]{{ \rule[16pt]{27pc}{0.5pt} }\newcommand{\secBXsixHone}[1]{{#1} } \newcommand{\secBXsixBTHleft}[1]{ {\rule[0pt]{44.45pc}{2pt}} \marginpar{ }\newcommand{\secBXsevenHone}[1]{{#1} }\newcommand{\secCOBH}[1] {{\uppercase{#1}} }\newcommand{\secCOLH}[1] {{\uppercase{#1}} }\newcommand{\secSMH}[1]{ {\rule[0pt]{40.5pc}{1pt}} \epsfig{file=../commonart/eoc2text.eps,
    height=4pt,width=40.5pc,clip=} \marginpar{ { \uppercase{#1} } } } \newcommand{\secSMHleft}[1]{ {\rule[0pt]{40.5pc}{0.5pt}} \epsfig{file=../commonart/eoc2text.eps,
    height=4pt,width=40.5pc,clip=} \marginpar{ \uppercase{#1} } } \newcommand{\secSMHtwo}[1]{{ #1} }\newcommand{\secEXRHone}[1]{{\uppercase{#1}} } \newcounter{EXRLLcount} { \marginpar{{From the Java Library} #1} } {\begin{minipage}{26pc}}{\end{minipage}} \rule[0pt]{27pc}{#1} } \begin{minipage}[t]{26pc} { \end{minipage} } \rule[0pt]{#2}{#1} } \begin{minipage}[t]{#2} { \end{minipage} } \rule[0pt]{40pc}{#1} } \begin{minipage}[t]{26pc} { \end{minipage} } \rule[0pt]{#2}{#1}
    <ul>
      <figure xml:id="fig-p528f1">
        <caption>A <c>JButton</c> has internal model-view-controller components that interact with each other to produce the button's overall behavior.</caption>
        <image width="73%" source="p528f1.eps"/>
      </figure>
      <li>
        <p>
          How can a button still be considered a component under the MVC model?
          This is a good question.
          The <c>JButton</c> class acts as a wrapper class and hides the model-view-controller details (Fig.
          <xref ref="fig-p528f1"></xref>).
          When you instantiate a <c>JButton</c>, you still get a single instance.
          Think of it this way: Your body consists of several systems that interact (internally) among themselves,
          but it's still one body that other bodies interact with as a single object.
        </p>
      </li>
      <li>
        <p>
          A component can indeed be registered with more than one listener.
          For example,
          the <c>ToggleButton</c> that we defined in <xref ref="chapter-io">Chapter</xref> has two listeners.
          The first is the button itself,
          which takes care of toggling the button's label.
          The second is the frame in which the button is used,
          which takes care of handling whatever action the button is associated with.
        </p>
      </li>
      <li>
        <p>
          Some components can have two different kinds of listeners.
          For example, imagine a
          <q>sticky button</q>
          that works like this.
          When you click and release the button,
          it causes some action to take place,
          just like a normal button.
          When you click and hold the mouse button down, the button
          <q>sticks</q>
          to the cursor and you can then move it to a new location.
          This button would need listeners for
<c>ActionEvent</c> s, <c>MouseEvent</c> s, and <c>MouseMotionEvent</c> s.
        </p>
      </li>
      <li>
        <p>
          To round a double you could use the <c>Math.round()</c> method.
          For example,
          suppose the number you want to round is <c>d</c>. Then the expression <c>Math.round(100 * d)/100.0</c> will round to two decimal places.
          Alternatively,
          you could use the
<c>java.text.NumberFormat</c> class.
          Both of these approaches were covered in Chapter<nbsp/>5.
        </p>
      </li>
      <li>
        <p>
          Many cars today have cruise control as a alternative way to control the accelerator.
          Push buttons, usually located on the steering wheel,
          are used to speed up and slow down,
          so you can drive with your foot or your hand.
        </p>
      </li>
      <li>
        <p>
          As an alternative,
          a north-west-center border layout for the top-level window in the <c>Converter</c> might work.
          So might center-south-east and center-south-west.
          What makes these possible is the fact that the layout manager will use up space in any edge area that is not assigned a component.
        </p>
      </li>
      <li>
        <p>
          A flow layout would not be appropriate for the control panel because you would have little control of where the <c>convert</c> button would be placed relative to the keypad.
        </p>
      </li>
      <li>
        <p>
          Interface design disaster: My car uses the same kind of on/off switch for the headlights and the windshield wipers.
          One is a stem on the left side of the steering wheel,
          and the other is on a stem on the right side of the steering wheel.
          On more than one occasion, I've managed to turn off the headlights when I intended to turn on the wipers.
        </p>
      </li>
      <li>
        <p>
          Modify the <c>addRecentCut()</c> method so it limits the cuts stored in the vector to the last ten cuts.
          Solution: Check the size of the vector after inserting the cut.
          If it exceeds ten,
          remove the last element in the vector.
<pre>
private void addRecentCut(String cut) {
  recentCuts.insertElementAt(cut, 0);
  if (recentCuts.size() > 10) { // If more than 10 cuts
    recentCuts.removeElementAt(10);  // remove oldest cut
  }
  cutsMenu.removeAll();
  for (int k = 0; k &lt; recentCuts.size(); k++) {
    JMenuItem item =
      new JMenuItem((String) recentCuts.elementAt(k));
    cutsMenu.add(item);
    item.addActionListener(this);
  }} // addRecentCut()
</pre>
        </p>
      </li>
      <li>
        <p>
          Modify the <c>addRecentCut()</c> method so that it doesn't duplicate cuts stored in the vector.
          Solution: Use the <c>indexOf()</c> method to search for the cut in the vector.
          If it's already there,
          don't insert the cut.
<pre>
private void addRecentCut(String cut) {
  if (recentCuts.indexOf(cut) == -1) {// If not already cut
    recentCuts.insertElementAt(cut,0);
    if (recentCuts.size() > 10) { // If more than 10 cuts
        recentCuts.removeElementAt(10); // remove oldest
    }
    cutsMenu.removeAll();
    for (int k = 0; k &lt; recentCuts.size(); k++) {
        JMenuItem item =
          new JMenuItem((String) recentCuts.elementAt(k));
        cutsMenu.add(item);
        item.addActionListener(this);
    }
  } // if not already cut} // addRecentCut()
</pre>
        </p>
      </li>
    </ul>
  </p>
  <ol>
    <li>
      <p>
        Explain the difference between the following pairs of terms:
        <ol>
          <li>
            <p>
              A <em>model</em> and a <em>view</em>.
            </p>
          </li>
          <li>
            <p>
              A <em>view</em> and a <em>controller</em>.
            </p>
          </li>
          <li>
            <p>
              A <em>lightweight</em> and <em>heavyweight</em> component.
            </p>
          </li>
          <li>
            <p>
              A <c>JButton</c> and a <c>Button</c>.
            </p>
          </li>
          <li>
            <p>
              A <em>layout manager</em> and a <em>container</em>.
            </p>
          </li>
          <li>
            <p>
              A <em>containment hierarchy</em>
              and an <em>inheritance hierarchy</em>.
            </p>
          </li>
          <li>
            <p>
              A <em>content pane</em> and a <c>JFrame</c>.
            </p>
          </li>
        </ol>
      </p>
      \marginpar{<term>Note:</term> For programming exercises,
      <term>first</term> draw a UML class diagram describing all classes and their inheritance relationships and/or associations.}
    </li>
    <li>
      <p>
        Fill in the blanks.
        <ol>
          <li>
            <p>
              A GUI component that is written entirely in Java is known as a \rule{40pt}{0.5pt} component.
            </p>
          </li>
          <li>
            <p>
              The AWT is not platform independent because it uses the \rule{40pt}{0.5pt} model to implement its GUI components.
            </p>
          </li>
          <li>
            <p>
              The visual elements of a GUI are arranged in a \rule{40pt}{0.5pt} .
            </p>
          </li>
          <li>
            <p>
              A \rule{40pt}{0.5pt} is an object that takes responsibility for arranging the components in a container.
            </p>
          </li>
          <li>
            <p>
              The default layout manager for a <c>JPanel</c> is \rule{40pt}{0.5pt} .
            </p>
          </li>
          <li>
            <p>
              The default layout manager for a <c>JApplet</c> is \rule{40pt}{0.5pt} .
            </p>
          </li>
        </ol>
      </p>
    </li>
    <li>
      <p>
        Describe in general terms what you would have to do to change the standard look and feel of a Swing <c>JButton</c>.
      </p>
    </li>
    <li>
      <p>
        Explain the differences between the model-view-controller design of a <c>JButton</c> and the design of an AWT <c>Button</c>. Why is MVC superior?
      </p>
    </li>
    <li>
      <p>
        Suppose you have a GUI that contains a \mbox{JButton} and a <c>JLabel</c>. Each time the button is clicked,
        the GUI rearranges the letters in the label.
        Using Java's event model as a basis,
        explain the sequence of events that happens in order for this action to take place.
      </p>
    </li>
    <li>
      <p>
        Draw a containment hierarchy for the most recent GUI version of the
<c>OneRowNim</c> program.
      </p>
    </li>
    <li>
      <p>
        Create a GUI design,
        similar to the one shown in <xref ref="fig-acmegui">Figure</xref>,
        for a program that would be used to buy tickets online for a rock concert.
      </p>
    </li>
    <li>
      <p>
        Create a GUI design,
        similar to the one shown in <xref ref="fig-acmegui">Figure</xref>,
        for an online program that would be used to play musical recordings.
      </p>
    </li>
    <li>
      <p>
        Design and implement a GUI for the <c>CDInterest</c> program (Fig.<nbsp/>5.18).
        This program should let the user input the interest rate,
        principal,
        and period and should accumulate the value of the investment.
      </p>
    </li>
    <li>
      <p>
        Design and implement a GUI for the <c>Temperature</c> class (Fig.<nbsp/>5.5).
        One challenge of this design is to find a good way for the user to indicate whether a Fahrenheit or Celsius value is being input.
        This should also determine the order of the conversion: F to C or C to F.
      </p>
    </li>
    <li>
      <p>
        Design an interface for a 16-button integer calculator that supports addition,
        subtraction, multiplication, and division.
        Implement the interface so that the label of the button is displayed in the calculator's display<mdash/>that is,
        it doesn't actually do the math.
        Challenge:  Design and implement a <c>Calculator</c> class to go along with the interface you developed in the previous exercise.
        It should function the same way as a hand calculator except it only handles integers.
      </p>
    </li>
    <li>
      <p>
        Modify the <c>Converter</c> application so that it can convert in either direction:
        from miles to kilometers or from kilometers to miles.
        Use radio buttons in your design to let the user select one or the other alternative.
      </p>
    </li>
    <li>
      <p>
        Here's a design problem for you.
        A biologist needs an interactive program that calculates the average of some field data represented as real numbers.
        Any real number could be a data value,
        so you can't use a sentinel value, such as 9999,
        to indicate the end of the input.
        Design and implement a suitable interface for this problem.
        Challenge: A dialog box is a window associated with an application that appears only when needed.
        Dialog boxes have many uses.
        An error dialog is used to report an error message.
        A file dialog is used to help the user search for and open a file.
        Creating a basic error dialog is very simple in Swing.
        The <c>JOptionPane</c> class has class methods that can be used to create the kind of dialog shown in <xref ref="fig-errdialog">Figure</xref>.
        Such a dialog box can be created with a single statement: \marginfiglarge{chptr13/9f28.eps}{A basic <c>JOptionPane</c> error dialog.}{fig-errdialog}
<pre>
JOptionPane.showMessageDialog(this,
         "Sorry, your number is out of range.");
</pre>Convert the <c>Validate</c> program (Fig.<nbsp/>6.12 from Chapter<nbsp/>6) to a GUI interface and use the <c>JOptionPane</c> dialog to report errors.
        Challenge: Design and implement a version of the game <em>Memory</em>.
        In this game you are given a two-dimensional grid of boxes that contains pairs of matching images or strings.
        The object is to find the matching pairs.
        When you click a box, its contents are revealed.
        You then click another box.
        If its contents match the first one,
        their contents are left visible.
        If not, the boxes are closed up again.
        The user should be able to play multiple games without getting the same arrangement every time.
        Challenge: Extend the <c>SimpleTextEditor</c> program by adding methods to handle the opening,
        closing and saving of text files.
      </p>
    </li>
  </ol>
</section>