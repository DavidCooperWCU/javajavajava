<section xml:id="sec-passby">
  <title>Passing a Value and Passing a Reference</title>
  <p>
    The effect of passing arguments to a method differs depending on whether you are passing a value of primitive type
        <idx><h>primitive type</h></idx>
    (such as 5 or <c>true</c>) or a value of reference type
        <idx><h>reference type</h></idx>
    (such as
    <q>Hello</q>
    or <c>game1</c>).
    When an argument of primitive type is \marginpar{Passing a primitive value} passed to a method,
    a copy of the argument is passed to the formal
  </p>
  <figure xml:id="fig-primcall">
    <caption>Passing a primitive value to a method.</caption>
<pre>
public class PrimitiveCall
{
   public static void myMethod(int n)
   {   System.out.println("myMethod: n= " + n);
       n = 100;
       System.out.println("myMethod: n= " + n);
   } // myMethod()
   public static void main(String argv[])
   {   int k = 5;
       System.out.println("main: k= " + k);
       myMethod(k);
       System.out.println("main: k= " + k);
   } // main()} // PrimitiveCall
</pre>
  </figure>
  <p>
    parameter.
    For example,
    consider the \mbox{PrimitiveCall} class shown in <xref ref="fig-primcall">Figure</xref>.
    Note that we have an <c>int</c> variable <c>k</c>, which initially stores the value 5, and a method
<c>myMethod()</c>, which takes an <c>int</c> parameter <c>n</c>. In this case,
    when we invoke <c>myMethod(k)</c>, <c>k</c>'s value (5) is copied into <c>n</c> and stored there during the method.
  </p>
  <p>
    One implication of passing a copy of a primitive value to a method is that the original value of <c>k</c> in <c>main()</c> cannot be altered from inside the method.
    Thus, the output generated by <c>PrimitiveCall</c> would be
  </p>
<pre>
main: k= 5
  myMethod: n= 5
  myMethod: n= 100
  main: k= 5
</pre>
  <p>
    Note that in <c>main()</c>, <c>k</c>'s value is printed both before and after <c>myMethod()</c> is called,
    but that its value remains unaffected even though <c>n</c>'s value is changed within the method.
    This is because <c>myMethod()</c> contains just a <em>copy</em>
    of <c>k</c>'s value,
    not <c>k</c> itself.
    Any changes to the copy within <c>myMethod()</c> leave <c>k</c> unaltered (See Fig.<nbsp/>3.8).
  </p>
  <principle>
    <title>Passing a Primitive Value</title>
    <p>
      When a value of a primitive type,
      like <c>boolean</c> or <c>int</c>, is passed to a method,
      a copy of the value is passed.
      That's why its original value remains unchanged outside the method,
      even if the copy is changed inside the method.
    </p>
  </principle>
  <figure xml:id="fig-vparameps">
    <caption>Tracing the state of variables k and n
    in <c>PrimitiveCall</c>(a) Just
    before calling <c>myMethod(k) in main</c>. (b) Just before executing the body
    of <c>myMethod()</c>. (c) Just after executing the body of <c>myMethod()</c>. (d) After flow of control returns to <c>main()</c>.</caption>
    <image width="73%" source="chptr03/vparam.png"/>
  </figure>
  <p>
    In contrast to this,
    when an argument of a reference type is passed to a method,
    a copy of the reference to the object itself is assigned to the parameter.
    For example,
    in the case of a <c>String</c> parameter or a <c>OneRowNim</c> parameter,
    the method would be given a reference to the object<ndash/>that is,
    the address of the object.
    The object itself is <em>not</em> passed,
    because it would be too inefficient to copy the entire object with all its data and methods.
    However, because the object's reference gives the object's location in memory,
    the method will have access to the object and can make changes to the original object from within the method.
  </p>
  <p>
    For example,
    consider the <c>ReferenceCall</c> class (Fig.
    <xref ref="fig-refcall"></xref>).
    In this case, <c>myMethod()</c> takes a
  </p>
  <figure xml:id="fig-refcall">
    <caption>Passing a reference value to a method.</caption>
<pre>
public class ReferenceCall
{
    public static void myMethod(OneRowNim g)
    {   System.out.print("myMethod: Number of sticks: ");
        System.out.println(g.getSticks());
        g.takeSticks(3);
        System.out.print("myMethod: Number of sticks: ");
        System.out.println(g.getSticks());
    } // myMethod()
    public static void main(String argv[])
    {   OneRowNim game = new OneRowNim(10);
         System.out.print("main: Number of sticks: ");
         System.out.println(game.getSticks());
         myMethod(game);
         System.out.print("main: Number of sticks: ");
         System.out.println(game.getSticks());
    }// main()} // ReferenceCall
</pre>
  </figure>
  <p>
    parameter <c>g</c> of type <c>OneRowNim</c>. Because a \mbox{OneRowNim} instance is an object, <c>g</c> is a reference variable.
    So when <c>myMethod(game)</c> is invoked in <c>main()</c>, a reference to
<c>game</c> is passed to <c>myMethod()</c>. Note that in <c>myMethod()</c>, we use <c>takeSticks(3)</c> to change the number of sticks of <c>g</c> from 10 to 7 and that this change persists even after the method returns control to <c>main()</c>. The reason is that during the method's execution,
    both <c>game</c> and <c>g</c> refer to the exact same object
    (see Fig.<nbsp/>3.10).
    The output generated by <c>ReferenceCall</c> would be
  </p>
<pre>
main: Number of sticks: 10
  myMethod: Number of sticks: 10
  myMethod: Number of sticks: 7
  main: Number of sticks: 7
</pre>
  <figure xml:id="fig-rparameps">
    <caption>Tracing the state of <c>OneRowNim</c> object
    in <c>ReferenceCall</c>(a) Just
    before calling <c>myMethod(game)</c>. (b) Just before executing the body
    of <c>myMethod()</c>. (c) Just after executing the body of <c>myMethod()</c>. (d) After flow of control returns to <c>main()</c>.</caption>
    <image width="73%" source="chptr03/rparam.png"/>
  </figure>
  <p>
    This illustrates that when passing a reference variable to a method,
    it is possible for the method to change the state of the object associated with the reference variable.
    In subsequent chapters we will see ways to make use of this feature of reference parameters.
  </p>
  <principle>
    <title>Passing a Reference</title>
    <p>
      When a reference to an object is passed to a method,
      any changes made to the object from within the method will persist when the method is finished executing.
    </p>
  </principle>
  <principle>
    <title>DEBUGGING TIP:Side Effects</title>
    <p>
      An unintended change to an object is called a <term>side effect</term>.
      Care should be taken in designing methods that the method does not produce unwanted side effects in objects passed as reference parameters.
    </p>
  </principle>
</section>